<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>gam0022.net</title>
    <link>https://gam0022.net/tags/raymarching/index.xml</link>
    <description>Recent content on gam0022.net</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>jp</language>
    <copyright>&amp;copy; 2021 gam0022</copyright>
    <atom:link href="/tags/raymarching/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Object Space Raymarching in Unreal Engine 5.2</title>
      <link>https://gam0022.net/blog/2023/07/31/raymarching-in-ue5/</link>
      <pubDate>Mon, 31 Jul 2023 10:00:00 +0900</pubDate>
      
      <guid>https://gam0022.net/blog/2023/07/31/raymarching-in-ue5/</guid>
      <description>&lt;p&gt;これは&lt;a href=&#34;https://sites.google.com/view/rtcamp9/home&#34;&gt;レイトレ合宿9&lt;/a&gt;のアドベントカレンダーの記事です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;あまりレイトレに関連しないテーマですが、レイは飛ばしているので大目に見てください&lt;/li&gt;
&lt;li&gt;レイトレ合宿ではレンダラーを自作する必要があるため、ゲームエンジンは使えません&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/RaymarchingInUE5_thumbnail_v7.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/RaymarchingInUE5_thumbnail_v7.jpg&#34; alt=&#34;Object Space Raymarching in Unreal Engine 5.2&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;はじめに&#34;&gt;はじめに&lt;/h1&gt;

&lt;p&gt;Unreal Engine 5.2上でオブジェクトスペースのレイマーチングを実装したので、その解説をします。&lt;/p&gt;

&lt;p&gt;レイマーチングをノードだけで実装するのは大変なので、MaterialのCustomノードを用いて複雑な処理はHLSLのコードで実装しました。&lt;/p&gt;

&lt;p&gt;UE（Unreal Engine）のプロジェクトはGitHubに公開しています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gam0022/RaymarchingInUE5/&#34;&gt;github.com/gam0022/RaymarchingInUE5/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Object Space Raymarching in Unreal Engine 5.2&lt;a href=&#34;https://twitter.com/hashtag/UE5?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#UE5&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/UnrealEngine?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#UnrealEngine&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/UnrealEngine5?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#UnrealEngine5&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/Shader?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#Shader&lt;/a&gt; &lt;a href=&#34;https://t.co/42n2W87HnJ&#34;&gt;pic.twitter.com/42n2W87HnJ&lt;/a&gt;&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/status/1684596333209075712?ref_src=twsrc%5Etfw&#34;&gt;July 27, 2023&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Randomization of glowing animation borders&lt;a href=&#34;https://twitter.com/hashtag/UE5?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#UE5&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/UnrealEngine?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#UnrealEngine&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/UnrealEngine5?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#UnrealEngine5&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/Shader?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#Shader&lt;/a&gt; &lt;a href=&#34;https://t.co/FvLbVtE9Q3&#34;&gt;pic.twitter.com/FvLbVtE9Q3&lt;/a&gt;&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/status/1685583942920089600?ref_src=twsrc%5Etfw&#34;&gt;July 30, 2023&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;読者対象&#34;&gt;読者対象&lt;/h2&gt;

&lt;p&gt;この記事は以下の読者を対象としています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1週間前の自分&lt;/li&gt;
&lt;li&gt;レイマーチングやシェーダーの実装経験はあるが、UEは初心者の方&lt;/li&gt;
&lt;li&gt;UEのカスタムシェーダーやMaterial Editorに興味がある方&lt;/li&gt;
&lt;li&gt;UE上でノードでは難しい複雑なシェーダーを実装してみたい人&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;結果&#34;&gt;結果&lt;/h2&gt;

&lt;p&gt;まずは実装結果を紹介します。&lt;/p&gt;

&lt;h3 id=&#34;オブジェクトスペースのレイマーチング&#34;&gt;オブジェクトスペースのレイマーチング&lt;/h3&gt;

&lt;p&gt;オブジェクトスペースのレイマーチングを実装しました。カスタムシェーダーをCubeに適用し、レイマーチングを行います。Cubeをレイマーチングのバウンディングボックスとして使用します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/object_space_raymarching_v1.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/object_space_raymarching_v1.png&#34; alt=&#34;オブジェクトスペースのレイマーチング&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;オブジェクトスペースにすることで、フルスクリーンのレイマーチングと比較して処理負荷を抑えることができます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;カメラではなくCubeの表面からレイを飛ばすことで、レイマーチングの衝突判定を少ないイテレーション回数に抑えられる&lt;/li&gt;
&lt;li&gt;レイマーチングの負荷の高いシェーダーの描画範囲を制限できる&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;パラメーターのリアルタイム編集&#34;&gt;パラメーターのリアルタイム編集&lt;/h3&gt;

&lt;p&gt;レイマーチングによる描画を行っているため、フラクタルのパラメーターをリアルタイムに編集できます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/param_v1.gif&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/param_v1.gif&#34; alt=&#34;IFSパラメーターのアニメーション1&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/param_v2.gif&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/param_v2.gif&#34; alt=&#34;IFSパラメーターのアニメーション2&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;▲グローのアニメーションのボーダーを乱数で散らしたバージョン&lt;/p&gt;

&lt;h3 id=&#34;actorのトランスフォームに追従&#34;&gt;Actorのトランスフォームに追従&lt;/h3&gt;

&lt;p&gt;オブジェクトスペースのレイマーチングの実装のため、Actor（UnityのGameObjectに相当）のトランスフォームに追従します。&lt;/p&gt;

&lt;h4 id=&#34;平行移動&#34;&gt;平行移動&lt;/h4&gt;

&lt;p&gt;平行移動の結果を見ると、UEのレンダリング結果と統合できていることがわかります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;他のオブジェクトと相互にライティングの影響を受けている&lt;/li&gt;
&lt;li&gt;床に反射し、ライティング結果が周囲に自然に馴染んでいる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/transform_translation_v1.gif&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/transform_translation_v1.gif&#34; alt=&#34;平行移動&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;回転&#34;&gt;回転&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/transform_rotation_v1.gif&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/transform_rotation_v1.gif&#34; alt=&#34;回転&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;拡大縮小&#34;&gt;拡大縮小&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/transform_scale_v1.gif&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/transform_scale_v1.gif&#34; alt=&#34;拡大縮小&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;実装の流れ&#34;&gt;実装の流れ&lt;/h2&gt;

&lt;p&gt;以下は実装の流れです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;UE上のHLSL（.ush）シェーダー開発環境の構築

&lt;ul&gt;
&lt;li&gt;C++の開発環境のセットアップ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AddShaderSourceDirectoryMapping&lt;/code&gt; を使用してシェーダーを配置するディレクトリを登録&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;UE上のレイマーチングの実装

&lt;ul&gt;
&lt;li&gt;HLSL（.ush）でレイマーチングを実装&lt;/li&gt;
&lt;li&gt;MaterialのCustomノードの &lt;code&gt;Include File Paths&lt;/code&gt; にHLSLシェーダー（.ush）を指定し、レイマーチングの関数を呼び出す&lt;/li&gt;
&lt;li&gt;Customノードの計算結果をResultノードに出力し、ライティング計算はエンジン側に任せる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;発展的な内容

&lt;ul&gt;
&lt;li&gt;オブジェクトスペースのレイマーチングに対応&lt;/li&gt;
&lt;li&gt;レイマーチングの空間にカメラが潜った場合を考慮&lt;/li&gt;
&lt;li&gt;他のオブジェクトの前後関係の解消&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;hlsl-ush-によるシェーダー開発環境の構築&#34;&gt;HLSL（.ush）によるシェーダー開発環境の構築&lt;/h2&gt;

&lt;p&gt;Unityでは、シェーダーファイル（.shader）をAssetsフォルダーに配置するだけで認識されますが、UEではシェーダーを明示的に配置するディレクトリをエンジンに認識させる必要があります。&lt;/p&gt;

&lt;p&gt;シェーダーを書くためにC++のコードを記述する必要があるのは面倒ですが、仕方ありませんね。&lt;/p&gt;

&lt;p&gt;C++の関数である&lt;a href=&#34;https://docs.unrealengine.com/5.2/en-US/API/Runtime/RenderCore/AddShaderSourceDirectoryMapping/&#34;&gt;AddShaderSourceDirectoryMapping&lt;/a&gt;を呼び出すことで、エンジンがHLSLシェーダー（.ush）を認識できるようになります。&lt;/p&gt;

&lt;p&gt;まずは、C++の開発環境を整える必要があります。以下の記事を参考に、UE用のC++の開発環境をセットアップしました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zenn.dev/posita33/books/ue5_starter_cpp_and_bp_001/viewer/chap_01_vs2022_setup&#34;&gt;Visual Studio 2022のセットアップ｜Unreal Engine 5から始める C++ &amp;amp; Blueprint&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;C++の開発環境をセットアップしたら、次の記事の「普通の方法」を参考にして、AddShaderSourceDirectoryMappingを呼び出してシェーダーを配置するディレクトリをエンジン側に登録します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/takaf51/items/cd98bd83fe5965d0de30#%E6%99%AE%E9%80%9A%E3%81%AE%E6%96%B9%E6%B3%95&#34;&gt;UE4,5 プロジェクトファイル内の外部シェーダーファイル(usf, ush, hlsl)をインクルードする為の設定。 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;手順を箇条書きにすると以下のようになります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C++プロジェクト化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;プロジェクト名.Build.cs&lt;/code&gt; に &lt;code&gt;RenderCore&lt;/code&gt; への依存関係を追加&lt;/li&gt;
&lt;li&gt;プロジェクトにモジュール開始と終了の関数を追加&lt;/li&gt;
&lt;li&gt;モジュール開始のStartupModule()に下記のコードを追加&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;FString ShaderDir = FPaths::Combine(FPaths::ProjectDir(), &amp;quot;Shaders&amp;quot;);
AddShaderSourceDirectoryMapping(&amp;quot;/Project&amp;quot;, ShaderDir);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードにより、プロジェクトの直下にある &lt;code&gt;Shaders&lt;/code&gt; ディレクトリに配置されたHLSLシェーダー（.ush）をエンジン側からIncludeできるようになります。&lt;/p&gt;

&lt;h3 id=&#34;余談-昔のueでhlslの関数定義やincludeは大変だった&#34;&gt;余談：昔のUEでHLSLの関数定義やincludeは大変だった&lt;/h3&gt;

&lt;p&gt;過去のUEでは、HLSLをIncludeすることができず、Customノードの展開される仕様を利用して、関数定義や#includeをインジェクションする必要があったようです。&lt;/p&gt;

&lt;p&gt;これは大変ですね。エンジンの改善により、HLSLのシェーダー開発がより使いやすくなったことは、喜ばしい進化と言えるでしょう。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;もんしょさんと話していたのは、カスタムノードをカッコで閉じちゃえば、あとは自由にコード書けちゃうぜ！というネタです。&lt;br&gt;実はこのTweetのマテリアルもこれを使用して書かれています。&lt;a href=&#34;https://t.co/y3P8BkDWyw&#34;&gt;https://t.co/y3P8BkDWyw&lt;/a&gt; &lt;a href=&#34;https://t.co/M4M5WX4u7m&#34;&gt;pic.twitter.com/M4M5WX4u7m&lt;/a&gt;&lt;/p&gt;&amp;mdash; Takuro Kayumi (@TakuroKX) &lt;a href=&#34;https://twitter.com/TakuroKX/status/670292440369094656?ref_src=twsrc%5Etfw&#34;&gt;November 27, 2015&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://monsho.hatenablog.com/entry/2015/12/23/120142&#34;&gt;Customノード3分ハッキング - もんしょの巣穴ブログ Ver2.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pafuhana1213.hatenablog.com/entry/2015/02/15/152312&#34;&gt;UE4のCustomノード(カスタムHLSLシェーダ)を使ってみた - ぼっちプログラマのメモ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;material全体&#34;&gt;Material全体&lt;/h2&gt;

&lt;p&gt;次の画像はMaterialのグラフ全体です。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_all_text.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_all_text.png&#34; alt=&#34;マテリアル全体&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;このグラフでは、レイマーチングの処理をHLSLで実装し、Customノードから呼び出しています。&lt;/p&gt;

&lt;p&gt;ノードとしては以下の処理のみ実装しています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;カメラのレイの生成&lt;/li&gt;
&lt;li&gt;前後関係の解消のためのPixel Depth Offsetの計算&lt;/li&gt;
&lt;li&gt;Emissiveのパターン計算&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;また、オブジェクトスペースのレイマーチングを行うための座標系の計算もノードで行われています。レイマーチングのCustomノードの前後にはTransformノードが接続されています。&lt;/p&gt;

&lt;h2 id=&#34;hlslシェーダーでレイマーチングを実装&#34;&gt;HLSLシェーダーでレイマーチングを実装&lt;/h2&gt;

&lt;p&gt;MaterialのCustomノードのDetailsからInclude File Pathsを指定し、HLSLファイル（.ush）をインクルードします。&lt;/p&gt;

&lt;p&gt;このとき「実際のファイルパス」と「Include File Paths」の指定に違いがある点に注意してください。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ファイルパスの例: &lt;code&gt;D:\UnrealProjects\プロジェクト名\Shaders\Raymarching.ush&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Include File Paths: &lt;code&gt;/Project/Raymarching.ush&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Raymarching.ush&lt;/code&gt; のHLSLコードの実装例は以下の通りです。レイマーチングの基本的な実装方法については説明しません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#pragma once

float sdBox(float3 p, float3 b)
{
    float3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

// メンガーのスポンジの距離関数
float dMenger(float3 z0, float3 offset, float scale, inout float4 ifsPosition)
{
    float4 z = float4(z0, 1.0);

    [loop]
    for (int n = 0; n &amp;lt; 4; n++)
    {
        z = abs(z);

        if (z.x &amp;lt; z.y) z.xy = z.yx;
        if (z.x &amp;lt; z.z) z.xz = z.zx;
        if (z.y &amp;lt; z.z) z.yz = z.zy;

        z *= scale;
        z.xyz -= offset * (scale - 1.0);

        if (z.z &amp;lt; - 0.5 * offset.z * (scale - 1.0))
        {
            z.z += offset.z * (scale - 1.0);
        }
    }

    ifsPosition = z;

    return (length(max(abs(z.xyz) - float3(1.0, 1.0, 1.0), 0.0)) - 0.05) / z.w;
}

float map(float3 pos, float uniformScale, float3 mengerOffst, float mengerScale, inout float4 ifsPosition)
{
    pos /= uniformScale;

    float d = dMenger(pos, mengerOffst, mengerScale, ifsPosition);
    d *= uniformScale;

    return d;
}

// 偏微分から法線を計算
float3 calcNormal(float3 p, float uniformScale, float3 mengerOffst, float mengerScale, inout float4 ifsPosition)
{
    float eps = 0.001;

    return normalize(float3(
        map(p + float3(eps, 0.0, 0.0), uniformScale, mengerOffst, mengerScale, ifsPosition) - map(p + float3(-eps, 0.0, 0.0), uniformScale, mengerOffst, mengerScale, ifsPosition),
        map(p + float3(0.0, eps, 0.0), uniformScale, mengerOffst, mengerScale, ifsPosition) - map(p + float3(0.0, -eps, 0.0), uniformScale, mengerOffst, mengerScale, ifsPosition),
        map(p + float3(0.0, 0.0, eps), uniformScale, mengerOffst, mengerScale, ifsPosition) - map(p + float3(0.0, 0.0, -eps), uniformScale, mengerOffst, mengerScale, ifsPosition)
    ));
}

// Ambient Occlusionを計算
float calcAO(float3 pos, float3 nor, float uniformScale, float3 mengerOffst, float mengerScale, inout float4 ifsPosition)
{
    float occ = 0.0;
    float sca = 1.0;

    for (int i = 0; i &amp;lt; 5; i++)
    {
        float h = 0.01 + 0.12 * float(i) / 4.0;
        float d = map(pos + h * nor, uniformScale, mengerOffst, mengerScale, ifsPosition);
        occ += (h - d) * sca;
        sca *= 0.95;
        if (occ &amp;gt; 0.35) break;
    }

    return saturate(clamp(1.0 - 3.0 * occ, 0.0, 1.0) * (0.5 + 0.5 * nor.y));
}

// エッジを計算
float calcEdge(float3 p, float uniformScale, float3 mengerOffst, float mengerScale, inout float4 ifsPosition)
{
    float edge = 0.0;
    float2 e = float2(0.01, 0);

    float d1 = map(p + e.xyy, uniformScale, mengerOffst, mengerScale, ifsPosition);
    float d2 = map(p - e.xyy, uniformScale, mengerOffst, mengerScale, ifsPosition);
    float d3 = map(p + e.yxy, uniformScale, mengerOffst, mengerScale, ifsPosition);
    float d4 = map(p - e.yxy, uniformScale, mengerOffst, mengerScale, ifsPosition);
    float d5 = map(p + e.yyx, uniformScale, mengerOffst, mengerScale, ifsPosition);
    float d6 = map(p - e.yyx, uniformScale, mengerOffst, mengerScale, ifsPosition);
    float d = map(p, uniformScale, mengerOffst, mengerScale, ifsPosition) * 2.;

    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);
    edge = smoothstep(0., 1., sqrt(edge / e.x * 2.));

    return edge;
}

// 原点にあるサイズが100x100x100のCubeの内部にいるかどうかを判定
float isInsideCube(float3 p)
{
    return sdBox(p, (50).xxx) &amp;lt;= 0;
}

void raymarching(
    // Inputs
    float3 origin, float3 ray, int raymarchingLoop,
    float uniformScale, float3 mengerOffst, float mengerScale,

    // Additional Outpus
    inout float hit, inout float depth, inout float3 hitPosition, inout float4 ifsPosition,
    inout float3 albedo, inout float3 normal, inout float ao, inout float emissive
)
{
    // レイマーチング
    hit = 0;
    depth = 0.0;// レイの進んだ距離
    float3 p = origin;// レイの先端の座標
    int i = 0;// レイマーチングのループカウンター

    [loop]
    for (i = 0; i &amp;lt; raymarchingLoop; i++)
    {
        float d = map(p, uniformScale, mengerOffst, mengerScale, ifsPosition);

        // 最短距離を0に近似できるなら、オブジェクトに衝突したとみなして、ループを抜けます
        if (abs(d) &amp;lt; 0.1)
        {
            break;
        }

        depth += d;// 最短距離だけレイを進めます
        p = origin + ray * depth;// レイの先端の座標を更新します
    }

    // バウンディングボックスの中にレイが留まっていればヒットしたと判定
    hit = isInsideCube(p);
    hitPosition = p;

    float4 _ifsPosition;

    if (hit)
    {
        // ライティングのパラメーター
        normal = calcNormal(p, uniformScale, mengerOffst, mengerScale, _ifsPosition);// 法線
        emissive = calcEdge(p, uniformScale, mengerOffst, mengerScale, _ifsPosition);// エッジ
        ao = calcAO(p, normal, uniformScale, mengerOffst, mengerScale, _ifsPosition);// AO
    }
    else
    {
        albedo = float3(0, 0, 0);
        discard;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;customノードのdetails&#34;&gt;CustomノードのDetails&lt;/h2&gt;

&lt;p&gt;CustomノードのDetailsは以下のように設定します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_custom_details.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_custom_details.png&#34; alt=&#34;CustomノードのDetails&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;CustomノードのCodeでは、raymarhcing関数を呼び出します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;albedo = objectAlbedo;

raymarching(
    origin, ray, raymarchingLoop,
    uniformScale, mengerOffst, mengerScale,
    hit, depth, hitPosition, ifsPosition,
    albedo, normal, ao, emissive
);

return albedo;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Inputs&lt;/code&gt;と&lt;code&gt;Additional Outpus&lt;/code&gt;には、&lt;code&gt;Raymarching.ush&lt;/code&gt;の&lt;code&gt;raymarching&lt;/code&gt;関数の全パラメーターを指定します。&lt;/p&gt;

&lt;p&gt;パラメーターの多い関数なので手間はかかりますが、ミスのないように注意しながら1個1個指定します。&lt;/p&gt;

&lt;p&gt;注意点として、関数のパラメーターの順序を変更したり、新しいパラメーターを追加すると、ノードの接続情報も再設定する必要があります。&lt;/p&gt;

&lt;!--
UEのMaterialのノードの接続は番号（整数のインデックス）で接続情報を保持しているようなので、パラメーターの順序を入れ替えたり、途中にパラメーターを追加すると、ノード上の接続もやり直しになります。
--&gt;

&lt;p&gt;繰り返しになりますが、Include File Pathsは実際のファイルパスとは異なる点に留意して、&lt;code&gt;/Project/Raymarching.ush&lt;/code&gt;と指定してください。&lt;/p&gt;

&lt;h2 id=&#34;material全体のdetails&#34;&gt;Material全体のDetails&lt;/h2&gt;

&lt;p&gt;Material全体のDetailsは以下のように設定します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_graph_details_text.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_graph_details_text.png&#34; alt=&#34;Material全体のDetails&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Material Domain: Surface

&lt;ul&gt;
&lt;li&gt;レイマーチングはボリュームレダリングの印象があるかもしれませんが、Surfaceで問題ありません&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Blend Mode: Masked

&lt;ul&gt;
&lt;li&gt;レイマーチングの衝突判定によって形状をマスクする必要があります&lt;/li&gt;
&lt;li&gt;このオプションを有効にすることで、Opacity Maskを出力できます

&lt;ul&gt;
&lt;li&gt;交差している場合は1、交差していない場合は0を出力します&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Shading Model: Default Lit

&lt;ul&gt;
&lt;li&gt;ライティング計算はエンジン側に任せます&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Two Sideded: ON

&lt;ul&gt;
&lt;li&gt;カメラがレイマーチングの内部に入った場合に両面描画が必要です&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;materialノード解説-カメラのレイの生成&#34;&gt;Materialノード解説：カメラのレイの生成&lt;/h2&gt;

&lt;p&gt;ここからはノードの解説をします。まずはカメラのレイを生成するためのノードです。&lt;/p&gt;

&lt;p&gt;次のようなノードでカメラのレイを生成しています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_camera_text.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_camera_text.png&#34; alt=&#34;Materialノード解説：カメラのレイの生成&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;レイは2つの3次元ベクトルで定義されます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;origin: レイの原点&lt;/li&gt;
&lt;li&gt;ray: レイの向き&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;rayの計算&#34;&gt;rayの計算&lt;/h3&gt;

&lt;p&gt;レイの方向（ray）はシンプルです。&lt;/p&gt;

&lt;p&gt;カメラの位置と、描画しようとしているSurfaceの座標（Absolute World Position）の差分（Subtract）から計算できます。&lt;/p&gt;

&lt;p&gt;正規化（Normalize）してから、Transform Vectorノードでワールドスペースからローカルスペースに変換しています。&lt;/p&gt;

&lt;p&gt;今回はオブジェクトスペースのレイマーチングのため、レイマーチングのCustomノードに入力する位置や向きはすべてローカルスペースに変換する必要があります。&lt;/p&gt;

&lt;h3 id=&#34;originの計算&#34;&gt;originの計算&lt;/h3&gt;

&lt;p&gt;レイの原点（origin）の計算には分岐（DynamicBranch）があります。&lt;/p&gt;

&lt;p&gt;これはカメラがレイマーチングの空間の内部に潜った場合を考慮しているためです。&lt;/p&gt;

&lt;p&gt;カメラの位置によってoriginを分岐しています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;カメラが外部にある場合: origin = Absolute World Position&lt;/li&gt;
&lt;li&gt;カメラが内部にある場合: origin = カメラの位置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;また、originもローカルスペースにする必要があるため、Transform Positionノードで変換しています。&lt;/p&gt;

&lt;p&gt;カメラの内部/外部の判定はInsideCubeノードで行われています。これもCustomノードです。&lt;/p&gt;

&lt;p&gt;Codeには &lt;code&gt;isInsideCube(localPos)&lt;/code&gt; と指定しています。これは&lt;code&gt;Raymarching.ush&lt;/code&gt;で定義された関数です。&lt;/p&gt;

&lt;p&gt;この分岐によって、カメラがレイマーチングの外部にある場合でも内部にある場合でも、問題なく動作するようになっています。&lt;/p&gt;

&lt;p&gt;また、「Two Sideded: ON」にしている理由は、カメラがレイマーチングの内部に入っている場合において、Cubeの裏面側でレイマーチングを描画するためです。&lt;/p&gt;

&lt;p&gt;これによって、以下のGIFアニメーションでは、カメラがレイマーチングの空間の内部に入り込んだ場合でも正常に描画されています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/camera_inside_v1.gif&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/camera_inside_v1.gif&#34; alt=&#34;カメラがレイマーチングの空間の内部に潜った場合&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;materialノード解説-resultノードへの出力&#34;&gt;Materialノード解説：Resultノードへの出力&lt;/h2&gt;

&lt;p&gt;RaymarchingのCustomノードの出力を、それぞれResultノードに接続します。&lt;/p&gt;

&lt;p&gt;これによりレイマーチングの衝突判定の結果をライティング計算に反映させます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;hit

&lt;ul&gt;
&lt;li&gt;レイマーチングの衝突判定の結果（0なら衝突しなかった、1なら衝突した）です&lt;/li&gt;
&lt;li&gt;Resultノードの &lt;code&gt;Opacity Mask&lt;/code&gt; に接続することで、レイマーチングがヒットしなかったPixelをdiscardできます&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;normal

&lt;ul&gt;
&lt;li&gt;ローカルスペースの法線です&lt;/li&gt;
&lt;li&gt;ワールドスペースに変換（TransformVector）してから、Resultノードの &lt;code&gt;Normal&lt;/code&gt; に接続します&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ao

&lt;ul&gt;
&lt;li&gt;[0-1]のパラメーターなので、そのままResultノードの &lt;code&gt;Ambient Occlusion&lt;/code&gt; に接続します&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_raymarching_result_text.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_raymarching_result_text.png&#34; alt=&#34;Materialノード解説：Resultノードへの出力&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;materialノード解説-前後関係の解決-pixel-depth-offsetの計算&#34;&gt;Materialノード解説：前後関係の解決（Pixel Depth Offsetの計算）&lt;/h2&gt;

&lt;p&gt;他のオブジェクトと重なった場合でも、前後関係を正しく解決するための工夫について説明します。&lt;/p&gt;

&lt;p&gt;以下のGIFアニメーションのように、白い球体と重なっている場合でも、前後関係を正しく解決できています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/depth_transform_v1.gif&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/depth_transform_v1.gif&#34; alt=&#34;前後関係の解決: 平行移動&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/depth_scale_v1.gif&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/depth_scale_v1.gif&#34; alt=&#34;前後関係の解決: スケール&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;UEのMaterialではDepthBufferを直接書き込むことはできませんが、ワールド座標でのDepthの押し込み距離から、Pixel Depth Offsetを計算することで前後関係を解決しています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_pixel_depth_offset_text.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_pixel_depth_offset_text.png&#34; alt=&#34;Materialノード解説：前後関係の解決（Pixel Depth Offsetの計算）&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Pixel Depth Offsetは、ワールド空間でのオフセット距離を計算する必要があります。したがって、Raymarchingの衝突点（hit）をTransform Positionノードを使用してワールド座標に変換し、Absolute World Positionとの差分（Subtract）を計算し、その距離（Length）を計算しています。&lt;/p&gt;

&lt;p&gt;Pixel Depth Offsetでは、カメラの奥方向にのみオフセットできます。逆に手前にオフセットさせることはできません。この制約は、パフォーマンスの向上を目的としています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/EGJ-Nori_Shinoyama/items/42cb29e95eca601250db&#34;&gt;[UE4] Pixel Depth Offsetは何故画面奥にしか行かないのかまた本当に重たいのかどうか問題 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;カメラがレイマーチングの内部にある場合、Cubeの裏面のSurfaceからは、衝突点（hit）が手前に来るため、Pixel Depth Offsetはマイナス値となります。
しかしこのマイナス値は利用できないため、カメラが内部にある場合は、&lt;code&gt;Pixel Depth Offset = 0&lt;/code&gt; となるようにLerpノードで分岐しています&lt;/p&gt;

&lt;!--
今回はLerpで分岐を処理しましたが、`Max(0, x)` でも良いと思います。
--&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;UE5.2でオブジェクトスペースのレイマーチングを実装できた

&lt;ul&gt;
&lt;li&gt;Actorに追従し、通常のMeshのようにギズモによりマウスで配置や変形ができる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;エンジンのレンダリング機能とも破綻なく統合できた

&lt;ul&gt;
&lt;li&gt;床への反射やグローバルイルミネーションに統合できた&lt;/li&gt;
&lt;li&gt;Opacity Mask、Pixel Depth Offsetを利用して、他のオブジェクトの前後関係なども解決できた&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ノードとコードの役割分担をうまくできた

&lt;ul&gt;
&lt;li&gt;複雑な処理はHLSLによるコードで実装し、Customノードで呼び出す&lt;/li&gt;
&lt;li&gt;オブジェクトスペースのための座標変換はノードを利用することでシンプルに実装できた&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;UEの細かいTipsについては別記事でまとめる予定

&lt;ul&gt;
&lt;li&gt;「Ctrl + 1 + 左クリック」でスカラーの定数ノードを作成できる&lt;/li&gt;
&lt;li&gt;VS2022プロジェクトの作成に失敗する場合、Source Code Editorを再選択すると解決することがある&lt;/li&gt;
&lt;li&gt;UnityとUEの座標系やスケールの違いについて&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考資料&#34;&gt;参考資料&lt;/h2&gt;

&lt;p&gt;UE4やUnity上でのレイマーチング実装の前例を以下に紹介します。これらの情報をとても参考にさせていただきました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://coposuke.hateblo.jp/entry/2019/12/11/002521&#34;&gt;【UE4】Object Space Raymarching (Material Editor) - コポうぇぶろぐ&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;UE4上でのレイマーチング実装の取り組み&lt;/li&gt;
&lt;li&gt;当時は Include File Paths が存在しなかったため、Customノードの関数定義に対するハックが必要であったことなどに触れています。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nanka.hateblo.jp/entry/2019/08/27/004905&#34;&gt;Unity HDRPのLitシェーダーを改造してレイマーチングする（GBuffer編） - なんかやる&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;Unity HDRP上でのレイマーチング実装の取り組み&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>『Unityゲーム プログラミング・バイブル 2nd Generation』のレイマーチングとTimelineの章を執筆しました</title>
      <link>https://gam0022.net/blog/2021/06/08/unity-bible2/</link>
      <pubDate>Tue, 08 Jun 2021 10:30:19 +0900</pubDate>
      
      <guid>https://gam0022.net/blog/2021/06/08/unity-bible2/</guid>
      <description>&lt;p&gt;6/29発売の&lt;a href=&#34;https://amzn.to/3oe2agf&#34;&gt;『Unityゲーム プログラミング・バイブル 2nd Generation』&lt;/a&gt;を執筆しました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2021-05-27-unity-bible2/Collage_Fotor.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2021-05-27-unity-bible2/Collage_Fotor.jpg&#34; alt=&#34;『Unityゲーム プログラミング・バイブル 2nd Generation』&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;『Unityゲーム プログラミング・バイブル 2nd Generation』について、公式ページから紹介文を引用します。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Unityのゲーム開発現場で最も使われた決定版書籍が、大幅バージョンアップして登場!&lt;/strong&gt;
&lt;strong&gt;ゲームの開発現場で即実践できるスキルが身につく!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;本書は、ゲーム開発で最も使われている「Unity」の入門や初級レベルを卒業した方向けの書籍です。ゲームの開発現場で、即実践できるスキルが身につくように、&lt;strong&gt;「37」の最新のトピックを網羅&lt;/strong&gt;しました。&lt;/p&gt;

&lt;p&gt;本書には、第一線の現場で活躍している23名の著者陣が参加しており、ゲーム開発のノウハウやTipsが満載されています。またほとんどのトピックでは、サンプルゲームがダウンロードでき、実際に動かしながら、実践的に学んでいくことが可能です。&lt;/p&gt;

&lt;p&gt;Unityでのゲーム開発のさまざまな場面で、すぐに役立つ1冊となっています。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--
![Unityゲーム プログラミング・バイブル 2nd Generation](/images/posts/2021-05-27-unity-bible2/Collage_Fotor.jpg)
--&gt;

&lt;p&gt;37のトピックのうち、私は次の2つを担当しました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;レイマーチング：基礎から応用まで&lt;/li&gt;
&lt;li&gt;Timelineによる映像制作&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;この記事では私の担当した内容を簡単に紹介します。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;『Unityゲーム プログラミング・バイブル 2nd Generation 』を執筆しました！&lt;br&gt;6/29発売です！&lt;br&gt;&lt;br&gt;・レイマーチング：基礎から応用まで&lt;br&gt;・Timelineによる映像制作&lt;br&gt;&lt;br&gt;の2本を担当しました。&lt;a href=&#34;https://t.co/lYWIxseCON&#34;&gt;https://t.co/lYWIxseCON&lt;/a&gt;&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/status/1392725305526161411?ref_src=twsrc%5Etfw&#34;&gt;May 13, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;レイマーチング-基礎から応用まで&#34;&gt;レイマーチング：基礎から応用まで&lt;/h1&gt;

&lt;div style=&#34;display: flex;&#34;&gt;
    &lt;div style=&#34;width: 50%;&#34;&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2021-05-27-unity-bible2/11_RaymarchingOpRepeat.jpg&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2021-05-27-unity-bible2/11_RaymarchingOpRepeat.jpg&#34; alt=&#34;サンプル11 距離関数の応用：無限複製編&#34; /&gt;&lt;/a&gt;&lt;/div&gt;
    &lt;div style=&#34;width: 50%;&#34;&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2021-05-27-unity-bible2/13_RaymarchingBoolean2.jpg&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2021-05-27-unity-bible2/13_RaymarchingBoolean2.jpg&#34; alt=&#34;サンプル13 距離関数の応用：無限複製とブーリアン演算の合せ技&#34; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;!--
![サンプル11 距離関数の応用：無限複製編](/images/posts/2021-05-27-unity-bible2/11_RaymarchingOpRepeat.jpg)
![サンプル13 距離関数の応用：無限複製とブーリアン演算の合せ技](/images/posts/2021-05-27-unity-bible2/13_RaymarchingBoolean2.jpg)
--&gt;

&lt;p&gt;このセクションでは「レイマーチング」という手法により、グラフィックスを描画する仕組みを紹介しました。&lt;/p&gt;

&lt;p&gt;レイマーチングと似た名前の手法にレイトレーシングがありますが、どちらもレイ、つまり光線をプログラムでシミュレーションしてカメラに映る画像を生成する手法です。&lt;/p&gt;

&lt;p&gt;レイマーチングでは、距離関数という数式で定義した形状に対して、レイとの交差判定を行うことで照明や反射などの計算を行います。
そのため、通常のUnityの描画パイプラインではできないような表現が可能になるということが特徴です。&lt;/p&gt;

&lt;p&gt;このセクションでは、Unityのシェーダーのコードを記述してレイマーチングを実装します。
レイマーチングの基礎から応用まで解説するために、合計13個のサンプルシーンを用意しました。
少しずつ処理を加えることで、一歩ずつレベルアップしながら理解を深められるチュートリアル形式のサンプルシーンになっています。&lt;/p&gt;

&lt;p&gt;サンプルプロジェクトは、筆者のGitHubにて公開しています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gam0022/UnityBible2-RaymarchingTutorial&#34;&gt;https://github.com/gam0022/UnityBible2-RaymarchingTutorial&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;このセクションで学べることとそのポイントを、以下にまとめておきます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;レイマーチングのアルゴリズムと本質

&lt;ul&gt;
&lt;li&gt;レイマーチングは魔法の道具ではなく、単なる衝突判定の手法&lt;/li&gt;
&lt;li&gt;数式（距離関数）によるプロシージャルなモデリング手法&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;コンピュータグラフィックスの基礎

&lt;ul&gt;
&lt;li&gt;レイマーチングが扱う範囲はあくまで衝突判定&lt;/li&gt;
&lt;li&gt;ライティングは通常のシェーダーとまったく同じように実装する必要がある&lt;/li&gt;
&lt;li&gt;Unityエンジンのシーンやライティング機能を利用せずに、グラフィックスを描画する一連の流れを学べるため、コンピュータグラッフィックスの学習教材としても有用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;執筆の裏話&#34;&gt;執筆の裏話&lt;/h2&gt;

&lt;p&gt;執筆の裏話としては作図にレイマーチングを利用しました。&lt;/p&gt;

&lt;p&gt;よくあるレイトレーシングの原理（スクリーン上のピクセルに対応する向きのレイを飛ばして交差判定）を解説するための図が欲しかったので、レイマーチングで作図しました。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;シェーダーは最強の作図ツールなので、&lt;br&gt;レイトレーシングの原理を説明するための図をUnityシェーダーだけで作りました。 &lt;a href=&#34;https://t.co/VuLBhoqEaY&#34;&gt;pic.twitter.com/VuLBhoqEaY&lt;/a&gt;&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/status/1343070779961839617?ref_src=twsrc%5Etfw&#34;&gt;December 27, 2020&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;ちゃんとアニメーションもできるように作り込んだのですが、書籍だと静止画になってしまうのが残念ですね。&lt;/p&gt;

&lt;h1 id=&#34;timelineによる映像制作&#34;&gt;Timelineによる映像制作&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2021-05-27-unity-bible2/00_Top.jpg&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2021-05-27-unity-bible2/00_Top.jpg&#34; alt=&#34;Timelineによる映像制作&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;このセクションでは、Unityの&lt;a href=&#34;https://docs.unity3d.com/ja/2019.2/Manual/TimelineOverview.html&#34;&gt;Timeline&lt;/a&gt;を利用した映像作品の制作について解説しました。&lt;/p&gt;

&lt;p&gt;このセクションで学べる項目は、以下の通りです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hecomi/uRaymarching&#34;&gt;uRaymarching&lt;/a&gt;を利用したレイマーチング&lt;/li&gt;
&lt;li&gt;Post-processing Stackの導入からビルトインエフェクトの利用、カスタムエフェクトの作成まで&lt;/li&gt;
&lt;li&gt;Timelineの基本からカスタムトラックの作成まで&lt;/li&gt;
&lt;li&gt;Cinemachineの基本的な使い方から、Post-processing Stackとの連携まで&lt;/li&gt;
&lt;/ul&gt;

&lt;!--
このセクションのサンプルシーンは、以下の各バージョンで作成しています。

- Unity 2020.1.8f1
- uRaymarching: v2.1.1
- Post-processing Stack（v2）2.3.0
- Timeline 1.3.6
- Cinemachine 2.6.3
- TextMeshPro 3.0.3
- Unity Recorder 2.5.2
--&gt;

&lt;p&gt;映像の作成のためには、数多くのUnityの機能とAssetを組み合わせる必要があります。&lt;/p&gt;

&lt;p&gt;それぞれのUnityの機能とAssetにフォーカスを当てた合計12個のサンプルシーンを用意しました。
サンプルシーンはチュートリアル形式で、一歩ずつレベルアップしながら理解を深められるようになっています。&lt;/p&gt;

&lt;p&gt;サンプルプロジェクトは、筆者のGitHubで公開しています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gam0022/UnityBible2-TimelineTutorial&#34;&gt;https://github.com/gam0022/UnityBible2-TimelineTutorial&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2021-05-27-unity-bible2/12_BeatSync.gif&#34; alt=&#34;サンプル12 音楽と同期して演出をブラッシュアップ&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;執筆の裏話-1&#34;&gt;執筆の裏話&lt;/h2&gt;

&lt;p&gt;これも執筆の裏話になりますが、&lt;strong&gt;デモのメイキングを書籍として出版する&lt;/strong&gt; という個人的な試みに今回はチャレンジしました。&lt;/p&gt;

&lt;p&gt;このツイートが伏線でした。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;RevisionのWriteup先には意外な &amp;quot;媒体&amp;quot; を予定しています&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/status/1379103521409101826?ref_src=twsrc%5Etfw&#34;&gt;April 5, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;サンプルの完成形のデモが『Secret stage BOSS』です。Revision2021のPC Demo Compoで初リリースしました。&lt;/p&gt;

&lt;p&gt;グラフィックスは私（&lt;a href=&#34;https://twitter.com/gam0022/&#34;&gt;@gam0022&lt;/a&gt;）、サウンドはさだきちさん（&lt;a href=&#34;https://twitter.com/sadakkey&#34;&gt;@sadakkey&lt;/a&gt;）が担当しました。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;&amp;quot;Secret stage BOSS&amp;quot; by &lt;a href=&#34;https://twitter.com/gam0022?ref_src=twsrc%5Etfw&#34;&gt;@gam0022&lt;/a&gt; &amp;amp; &lt;a href=&#34;https://twitter.com/sadakkey?ref_src=twsrc%5Etfw&#34;&gt;@sadakkey&lt;/a&gt;&lt;br&gt;&lt;br&gt;Our new PC Demo for &lt;a href=&#34;https://twitter.com/hashtag/Revision2021?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#Revision2021&lt;/a&gt; (&lt;a href=&#34;https://twitter.com/revision_party?ref_src=twsrc%5Etfw&#34;&gt;@revision_party&lt;/a&gt;)&lt;br&gt;&lt;br&gt;It&amp;#39;s a Massive Greetings to &amp;quot;2nd stage BOSS&amp;quot; &lt;a href=&#34;https://t.co/vVWJJB4cyS&#34;&gt;pic.twitter.com/vVWJJB4cyS&lt;/a&gt;&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/status/1378967812463501313?ref_src=twsrc%5Etfw&#34;&gt;April 5, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;『Secret stage BOSS』は&lt;a href=&#34;https://youtu.be/SFoyJED5A4s&#34;&gt;『2nd stage BOSS by 0x4015&amp;amp;YET11』&lt;/a&gt;というデモシーン歴史に残る伝説級のデモのオマージュ作品です。&lt;/p&gt;

&lt;p&gt;自機やボスが登場するシューティングゲーム風のストーリーを、自分たちなりのビジュアルと音楽のスタイルで再現しました。&lt;/p&gt;

&lt;div class=&#34;movie-wrap&#34;&gt;
&lt;iframe width=&#34;1920&#34; height=&#34;1080&#34; src=&#34;https://www.youtube.com/embed/srO7IxNckZ8&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;GitHub上でUnityプロジェクトを丸ごと公開しているので、もし興味があれば参考にしてください。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;You can see the source code &amp;amp; Unity project on GitHub!&lt;br&gt;&lt;br&gt;ソースコードとUnityプロジェクトをGitHubで公開しました！&lt;a href=&#34;https://t.co/dQJV35DGKB&#34;&gt;https://t.co/dQJV35DGKB&lt;/a&gt;&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/status/1378975301456130049?ref_src=twsrc%5Etfw&#34;&gt;April 5, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h1 id=&#34;おわりに&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;6年前にレイマーチングと出会ってから、レイマーチングの面白さに魅せられ続け、レイマーチングに関するさまざまな情報を発信してきました。
今回、Unityの一般ユーザー向けの書籍でレイマーチングについて解説をする機会をいただけたことをとても光栄に思います。
これまでシェーダーと縁がなかった方にもシェーダーに興味をもってもらえれば幸いです。&lt;/p&gt;

&lt;p&gt;日本語で書かれたレイマーチングの入門情報はかなり充実してきましたが、その次のステップの情報が不足しているように感じていました。
本書ではレイマーチングの中級者向けの情報として、距離関数によるモデリングや本格的なライティングまで解説しました。
レイマーチングで球体のレンダリングはできたけど、その次のステップが分からないという方にぜひ読んでいただきたいです。&lt;/p&gt;

&lt;p&gt;本書は定価8580円と気軽に購入しづらいかもしれませんが、&lt;strong&gt;フルカラーの1112ページ、扱うテーマの広さ、得られる情報の密度&lt;/strong&gt;を踏まえると妥当（むしろお買い得！）な値段だと思います。
初版部数はAmazonでの予約数をもとに決まるそうなので、ぜひ&lt;a href=&#34;https://amzn.to/3oe2agf&#34;&gt;Amazonから予約&lt;/a&gt;をお願いします！&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;リアルタイムレンダリング 第4版よりもページ数が多いことに気がついて驚いています。 &lt;a href=&#34;https://t.co/zJGUYOm8XL&#34;&gt;https://t.co/zJGUYOm8XL&lt;/a&gt;&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/status/1393040315762634755?ref_src=twsrc%5Etfw&#34;&gt;May 14, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h1 id=&#34;追記-2021-08-21&#34;&gt;追記（2021-08-21）&lt;/h1&gt;

&lt;p&gt;7/29の「Unityゲーム プログラミング・バイブル 2nd Generation 出版記念トーク グラフィックス編」にゲスト出演しました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://learning.unity3d.jp/7437/&#34;&gt;Unityゲーム プログラミング・バイブル 2nd Generation 出版記念トーク グラフィックス編&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Windows Terminalの背景でレイマーチング</title>
      <link>https://gam0022.net/blog/2021/03/08/raymarching-in-windows-terminal/</link>
      <pubDate>Mon, 08 Mar 2021 01:00:00 +0900</pubDate>
      
      <guid>https://gam0022.net/blog/2021/03/08/raymarching-in-windows-terminal/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2021-02-26-raymarching-in-windows-terminal/raymarching-in-windows-terminal.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2021-02-26-raymarching-in-windows-terminal/raymarching-in-windows-terminal.jpg&#34; alt=&#34;Raymarching in Windows Terminal&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Windows Terminal 1.6から任意のHLSLのPixel Shadersを実行できるようになったので、Windows Terminalの背景でレイマーチングを実行してみました。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;Raymarching in Windows Terminal&lt;br&gt;&lt;br&gt;Windows Terminal 1.6 から任意の Pixel Shaders を実行できるようになったので、Windows Terminal の背景でレイマーチングを実行してみた🎉 これは楽しすぎる🤣 &lt;a href=&#34;https://t.co/WX2JqUZtuL&#34;&gt;pic.twitter.com/WX2JqUZtuL&lt;/a&gt;&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/status/1361485111473045505?ref_src=twsrc%5Etfw&#34;&gt;February 16, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;2021-02-16のツイート時点では、Windows Terminal 1.6はまだPreview版なので、GitHubのReleasesページから入手する必要がありました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/microsoft/terminal/releases/tag/v1.6.10412.0&#34;&gt;https://github.com/microsoft/terminal/releases/tag/v1.6.10412.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2021-03-07現在では、Windows Terminal 1.6からPreviewが外れてMicrosoft Storeから入手できるようになりました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.microsoft.com/ja-jp/p/windows-terminal/9n0dx20hk701?activetab=pivot:overviewtab&#34;&gt;Windows Terminal を入手 - Microsoft Store ja-JP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Windows TerminalのPixel Shaders機能の詳細については、公式ドキュメントをご覧ください。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/microsoft/terminal/tree/main/samples/PixelShaders&#34;&gt;https://github.com/microsoft/terminal/tree/main/samples/PixelShaders&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;任意のHLSLのシェーダーのファイルを作成して、Windows Terminalのsettings.jsonの &lt;code&gt;experimental.pixelShaderPath&lt;/code&gt; からHLSLファイルのパスを設定するだけで、気軽に任意のシェーダーを実行できます。素晴らしい！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;quot;profiles&amp;quot;:
  {
    &amp;quot;defaults&amp;quot;:
    {
      &amp;quot;experimental.pixelShaderPath&amp;quot;: &amp;quot;C:\\Users\\gam0022\\Dropbox\\windows-terminal\\terminal\\samples\\PixelShaders\\Raymarching.hlsl&amp;quot;
    },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;レイマーチング用のシェーダーはUnityで下書きしたものをWindows Terminal用に移植して実装しました。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;Raymarching in Windows Terminal のシェーダーを公開しました。&lt;br&gt;&lt;br&gt;（シェーダー初心者にも優しい）日本語コメントつき！&lt;a href=&#34;https://t.co/GPEpIlHOyD&#34;&gt;https://t.co/GPEpIlHOyD&lt;/a&gt;&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/status/1361495940356476929?ref_src=twsrc%5Etfw&#34;&gt;February 16, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;HLSLのエラーの行番号が表示されないので、複雑なシェーダーを書くのはちょっと苦労しました。&lt;/p&gt;

&lt;p&gt;基本的にはUnityのShaderLab用のプロパティや &lt;code&gt;_LightColor0&lt;/code&gt; などのビルドインのシェーダー変数を定数（static const）として宣言する修正だけで移植できました。&lt;/p&gt;

&lt;p&gt;Windows Terminal用のPixel Shadersでは、以下のテクスチャのサンプラーや定数が定義されていました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// The terminal graphics as a texture
// ターミナルの文字などを含んだターミナルのレンダリング結果のサンプラー
Texture2D shaderTexture;
SamplerState samplerState;

// Terminal settings such as the resolution of the texture
cbuffer PixelShaderSettings {
  // The number of seconds since the pixel shader was enabled
  // 秒単位の時間
  float Time;

  // UI Scale
  // UIのスケール
  float Scale;
  
  // Resolution of the shaderTexture
  // ピクセル単位の背景の解像度
  float2 Resolution;
  
  // Background color as rgba
  // 背景の色
  float4 Background;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;shaderTexture&lt;/code&gt; はターミナルの文字などを含んだターミナルのレンダリング結果のサンプラーになるので、今回は背景に加算合成する形でシェーダーを実装しました（加算合成なので後からレイマーチングを加算しても結果は同じになるため、描画順を気にしなてくて良い）。&lt;/p&gt;

&lt;h1 id=&#34;hlslのホットリロードでシェーダーライブコーディング環境を実現&#34;&gt;HLSLのホットリロードでシェーダーライブコーディング環境を実現&lt;/h1&gt;

&lt;p&gt;Windows Terminal 1.6の挙動では、シェーダーを再コンパイルして結果を更新するために以下の手順が必要だったので、ライブコーディングには不向きでした。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;experimental.pixelShaderPath&lt;/code&gt; で指定したHLSLシェーダーに差分を出してファイル保存&lt;/li&gt;
&lt;li&gt;Windows Terminalの &lt;code&gt;settings.json&lt;/code&gt; の &lt;code&gt;experimental.pixelShaderPath&lt;/code&gt; の値に差分を出してファイル保存&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最初の動画ではシェーダーの描画結果をリアルタイムで更新するために、Vimで2つのファイルを同時編集することで、リアルタイムにライブコーディングっぽいことをしていましたが、かなり操作が忙しいので非実用的でした。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Vimの左側ペイン: HLSLのシェーダー&lt;/li&gt;
&lt;li&gt;Vimの右側ペイン: Windows Terminalのsettings.json&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;そこで、HLSLの更新を検知して、Windows Terminalの &lt;code&gt;settings.json&lt;/code&gt; を書き換えることで、HLSLのホットリロードを実現するスクリプトをnode.jsで実装しました。&lt;/p&gt;

&lt;p&gt;これによって、Windows Terminalの背景でHLSLシェーダーライブコーディングを実現できるようになりました！&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;Windows Terminal 上のHLSLシェーダーライブコーディング環境を実現するスクリプトをGitHubに公開しました！&lt;br&gt;&lt;br&gt;&amp;gt; HLSLの変更を監視して、settings.json を書き換え&lt;a href=&#34;https://t.co/hjB2MqgsSx&#34;&gt;https://t.co/hjB2MqgsSx&lt;/a&gt;&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/status/1361706800282656769?ref_src=twsrc%5Etfw&#34;&gt;February 16, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Windows Terminalの &lt;code&gt;settings.json&lt;/code&gt; に毎回差分を出すために、HLSLファイルをコピーした一時ファイルを作成して、元のファイルのパスと一時ファイルのパスを交互に切り替えて &lt;code&gt;experimental.pixelShaderPath&lt;/code&gt; に設定するような実装としました。&lt;/p&gt;

&lt;h1 id=&#34;感想&#34;&gt;感想&lt;/h1&gt;

&lt;p&gt;Windows TerminalというMicrosoft公式のアプリ上でHLSLシェーダーライブコーディング環境を実現できるのは熱いですね！楽しい！！&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>

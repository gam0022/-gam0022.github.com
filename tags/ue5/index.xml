<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>gam0022.net</title>
    <link>https://gam0022.net/tags/ue5/index.xml</link>
    <description>Recent content on gam0022.net</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>jp</language>
    <copyright>&amp;copy; 2021 gam0022</copyright>
    <atom:link href="/tags/ue5/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>[UE5] プロシージャルコンテンツ生成（PCG）最初に知っておきたいポイントと実践TIPS</title>
      <link>https://gam0022.net/blog/2024/01/01/ue5-pcg-introduction-tips/</link>
      <pubDate>Mon, 01 Jan 2024 14:00:00 +0900</pubDate>
      
      <guid>https://gam0022.net/blog/2024/01/01/ue5-pcg-introduction-tips/</guid>
      <description>&lt;p&gt;新年あけましておめでとうございます！&lt;/p&gt;

&lt;p&gt;大変遅刻しましたが、&lt;a href=&#34;https://qiita.com/advent-calendar/2023/ue&#34;&gt;Unreal Engine (UE) Advent Calendar 2023&lt;/a&gt;の13日目の記事です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;UE5.2から&lt;a href=&#34;https://docs.unrealengine.com/5.3/ja/procedural-content-generation-overview/&#34;&gt;プロシージャルコンテンツ生成フレームワーク (PCG：Procedural Content Generation Framework) &lt;/a&gt;が追加されました。&lt;/p&gt;

&lt;p&gt;PCGを利用すると、大量のStaticMeshの配置などの手動では大変な作業を自動化に役立ちます。&lt;/p&gt;

&lt;p&gt;Houdini Engine for Unreal Engineでも同じことは可能ですが、UE内で作業が完結するため、よりイテレーションを回せることがメリットだと思います。&lt;/p&gt;

&lt;p&gt;最近PCGを使う機会があったので、PCGについて最初に知りたかったポイントや、よく使うパターンの実践TIPSをまとめます。&lt;/p&gt;

&lt;p&gt;執筆時のバージョンはUE5.3.2です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-12-27-ue5-pcg-introduction-tips/ogp.jpg&#34; alt=&#34;OGP画像&#34; /&gt;&lt;/p&gt;

&lt;p&gt;UE5のサンプルプロジェクトはGitHubに公開しています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gam0022/UE5_Examples&#34;&gt;github.com/gam0022/UE5_Examples&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gam0022/UE5_Examples/tree/main/Content/PCGExamples&#34;&gt;Content/PCGExamples&lt;/a&gt; フォルダを参照してください&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;pcgのセットアップ&#34;&gt;PCGのセットアップ&lt;/h1&gt;

&lt;p&gt;以下のプラグインを有効化してください。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Procedural Content Generation Framework&lt;/li&gt;
&lt;li&gt;Procedural Content Generation Framework Geometry Script Interop&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;pcgの基本的な使い方&#34;&gt;PCGの基本的な使い方&lt;/h1&gt;

&lt;p&gt;PCGの基本的な使い方については、たくさんの入門記事があるため、今回は割愛します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://historia.co.jp/archives/34360/&#34;&gt;[UE5] PCGの特徴と使い方｜株式会社ヒストリア&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://unrealengine.hatenablog.com/entry/2023/05/27/221601&#34;&gt;UE5 PCG（Procedural Content Generation）ガッツリ入門 - Let&amp;#39;s Enjoy Unreal Engine&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Level上にPCG Volumeを作成して、PCGのGraph InstanceにPCG Graphを設定します。&lt;/p&gt;

&lt;h1 id=&#34;pcgの最初に知りたかったポイント&#34;&gt;PCGの最初に知りたかったポイント&lt;/h1&gt;

&lt;h2 id=&#34;example01-シンプルなpcgの例&#34;&gt;Example01: シンプルなPCGの例&lt;/h2&gt;

&lt;p&gt;Landscape上にランダムにMeshを配置し、Mesh同士がぶつからないようにするシンプルなPCGの例です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-12-27-ue5-pcg-introduction-tips/example01-result.jpg&#34; alt=&#34;シンプルなPCGの例 Example01 結果&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-12-27-ue5-pcg-introduction-tips/example01-graph.png&#34; alt=&#34;シンプルなPCGの例 Example01 PCGGraph&#34; /&gt;&lt;/p&gt;

&lt;p&gt;このPCGでは、以下の4ステップの処理を行っています。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;ポイントの生成

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Get Landscape Data&lt;/code&gt; でLandscapeを取得&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Surface Sampler&lt;/code&gt; でLandscapeに対してポイントを生成&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ポイントの処理

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Transform Points&lt;/code&gt; でランダムな移動と回転&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ポイントのフィルター

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Bounds Modifier&lt;/code&gt; でバウンディングボックスを調整&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Self Pruning&lt;/code&gt; で自己干渉しているポイントを消去&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;StaticMeshを生成

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Static Mesh Spawner&lt;/code&gt; でStaticMeshを生成&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;PCGではポイントを生成してから、ポイントのAttributeを何かしらの方法で加工し、最後にStatic Mesh SpawnerでStaticMeshを生成という流れになります。&lt;/p&gt;

&lt;p&gt;そのため、ポイントにどんなAttributeが存在していて、どのように値が変化するのかを意識することがとても重要です。&lt;/p&gt;

&lt;p&gt;この4ステップの流れは複雑なPCGでもほとんど変わらない定型パターンになります。&lt;/p&gt;

&lt;h2 id=&#34;inspect機能でattributeの内容を確認する&#34;&gt;Inspect機能でAttributeの内容を確認する&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;「ポイントのAttributeの内容をInspect機能で常に確認しよう」&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;この記事で一番伝えたかったポイントです。Attributeの変化を意識することが、PCGマスターへの近道です。&lt;/p&gt;

&lt;p&gt;Houdiniの経験がある方は実感できるのではないでしょうか。&lt;/p&gt;

&lt;p&gt;参考記事: &lt;a href=&#34;https://note.com/aoi/n/n3633a8fb6fc0&#34;&gt;絶対に挫折しないHoudini入門 4 - オブジェクトとジオメトリ｜aoi&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;PCGのポイントはAttributeを持っています。これらがAttributeの具体例です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Position&lt;/li&gt;
&lt;li&gt;Rotation&lt;/li&gt;
&lt;li&gt;Scale&lt;/li&gt;
&lt;li&gt;BoundsMin / BoundsMax&lt;/li&gt;
&lt;li&gt;Color&lt;/li&gt;
&lt;li&gt;Density&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Inspect機能は、ポイントのAttributeを内容を確認するための機能です。HoudiniのGeometry Spreadsheetに相当する機能です。&lt;/p&gt;

&lt;p&gt;PCGの上部のタブから &lt;code&gt;No Debug object selected&lt;/code&gt; と書かれている項目をプルダウンで変更し、現在のPCG Graph名 / PCG Compornetを選んでください。
ノードを右クリックしてInspectにチェックすると、そのノードの処理時点のPointの持つAttributeが表示されます。&lt;/p&gt;

&lt;p&gt;ショートカットとして、ノードを選択してからAキーを押してもInspectが有効になります。&lt;/p&gt;

&lt;p&gt;Inspect中のノードは左上に黄色い●が表示されます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-12-27-ue5-pcg-introduction-tips/pcg-inspect.png&#34; alt=&#34;Inspect機能&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;debug機能でビューポート上でポイントを確認する-self-pruningで重なりを除去&#34;&gt;Debug機能でビューポート上でポイントを確認する + Self Pruningで重なりを除去&lt;/h2&gt;

&lt;p&gt;Debug機能はViewport上でポイントを可視化する機能です。ノードを右クリックしてDebugにチェックするか、Dキーを押すことで有効になります。&lt;/p&gt;

&lt;p&gt;Debug中のノードは左上に青い●が表示されます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-12-27-ue5-pcg-introduction-tips/pcg-debug.png&#34; alt=&#34;Debug機能&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ビューポート上の白・黒・グレーの箱がDebugの表示です。&lt;/p&gt;

&lt;p&gt;箱の色はDensityに対応しており、箱の大きさは &lt;code&gt;Scale&lt;/code&gt; と &lt;code&gt;BoundsMin / BoundsMax&lt;/code&gt; に対応します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Self Pruning&lt;/code&gt; はポイントが持つバウンディングボックスのAttributeに対して判定が行われます。&lt;/p&gt;

&lt;p&gt;そのため、ステップ3のポイントのフィルターでは、まず &lt;code&gt;Bounds Modifier&lt;/code&gt; でバウンディングボックスを調整してから &lt;code&gt;Self Pruning&lt;/code&gt; しています。&lt;/p&gt;

&lt;p&gt;Inspect機能とDebug機能をつかって、ポイントのAttributeの変化を確認することが、PCGの作業効率アップやPCGへの理解度がアップにつながります。&lt;/p&gt;

&lt;h1 id=&#34;pcgの実践tips&#34;&gt;PCGの実践TIPS&lt;/h1&gt;

&lt;p&gt;PCGでよく使いそうなパターンの実践TIPSを紹介します。&lt;/p&gt;

&lt;h2 id=&#34;example02-特定のstaticmeshを避けて配置&#34;&gt;Example02: 特定のStaticMeshを避けて配置&lt;/h2&gt;

&lt;p&gt;特定のオブジェクトを避けて配置する例です。&lt;/p&gt;

&lt;p&gt;まず手動でテーブルのStaticMeshを配置し、ActorのTagsに &lt;code&gt;SM_Table&lt;/code&gt; を設定します。&lt;/p&gt;

&lt;p&gt;対応前：Example01のままだと、テーブルと椅子が重なり合ってしまいます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-12-27-ue5-pcg-introduction-tips/example02-result-before.jpg&#34; alt=&#34;Example02: 対応前&#34; /&gt;&lt;/p&gt;

&lt;p&gt;対応後：重ならないようになりました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-12-27-ue5-pcg-introduction-tips/example02-result-after.jpg&#34; alt=&#34;Example02: 対応後&#34; /&gt;&lt;/p&gt;

&lt;p&gt;これがPCG Graphです。オレンジ色の枠で部分がExample01から新しく追加した処理です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-12-27-ue5-pcg-introduction-tips/example02-graph1.png&#34; alt=&#34;Example02: Graphの全体&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;get-actor-dataの設定&#34;&gt;Get Actor Dataの設定&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-12-27-ue5-pcg-introduction-tips/example02-graph2.png&#34; alt=&#34;Example02: GraphのGet Actor Data&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Get Actor Dataはアクターを取得するノードです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Actor Filter: All World Acotrs&lt;/li&gt;
&lt;li&gt;Must Overlap Self: ON（Volumeの範囲内だけに限定します）&lt;/li&gt;
&lt;li&gt;Actor Selection Tag: SM_Talbe（StaticMeshに設定したタグを指定）&lt;/li&gt;
&lt;li&gt;Select Multiple: ON（テーブルが複数ある場合はONにします。基本的にONで良いと思います）&lt;/li&gt;
&lt;li&gt;Mode: Get Single Point&lt;/li&gt;
&lt;li&gt;Merge Single Point Data: ON&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;differenceの設定&#34;&gt;Differenceの設定&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-12-27-ue5-pcg-introduction-tips/example02-graph3.png&#34; alt=&#34;Example02: GraphのDifference&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Differenceは差集合を計算するノードです。今回の例では、テーブルのバウンディングボックスと重なる椅子を削除します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Density Function: Binary&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;example02のまとめ&#34;&gt;Example02のまとめ&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Get Actor Dataでは、Tagでフィルターすることで特定のActorやStaticMeshを取得できます。&lt;/li&gt;
&lt;li&gt;Differenceを使うことで特定の範囲内のポイントを消去できます。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;example03-特定のstaticmeshの周囲に配置&#34;&gt;Example03: 特定のStaticMeshの周囲に配置&lt;/h2&gt;

&lt;p&gt;岩を手動配置して、その周りに花を自動配置する例です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-12-27-ue5-pcg-introduction-tips/example03-result.jpg&#34; alt=&#34;Example03: 結果&#34; /&gt;&lt;/p&gt;

&lt;p&gt;PCG Graphの全体図です。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-12-27-ue5-pcg-introduction-tips/example03-graph-all.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-12-27-ue5-pcg-introduction-tips/example03-graph-all.png&#34; alt=&#34;Example03: PCG Graphの全体図&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;岩の周囲にポイントを生成する&#34;&gt;岩の周囲にポイントを生成する&lt;/h3&gt;

&lt;p&gt;まずは岩のアクターの周囲にポイントを生成します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-12-27-ue5-pcg-introduction-tips/example03-graph1.png&#34; alt=&#34;Example03: バウンディングボックスを指定したSurfaceSampler&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Example02と同じようにTag指定で岩のActorを取得し、&lt;code&gt;Bounds Modifier&lt;/code&gt; でバウンディングボックスを5倍に拡大します。&lt;/p&gt;

&lt;p&gt;Surface SamplerのBounding Shapeに拡大したバウンディングボックスを指定することで、岩の周囲にポイントを生成できます。&lt;/p&gt;

&lt;p&gt;ポイントの生成範囲を調整する場合は &lt;code&gt;Bounds Modifier&lt;/code&gt; で5倍の数値を調整します。&lt;/p&gt;

&lt;h3 id=&#34;distanceノードで岩からの距離に応じたdensityを設定する&#34;&gt;Distanceノードで岩からの距離に応じたDensityを設定する&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-12-27-ue5-pcg-introduction-tips/example03-graph-distance.png&#34; alt=&#34;Example03: Distanceノード&#34; /&gt;&lt;/p&gt;

&lt;p&gt;DistanceノードでTargetへのPointの距離を計算できます。&lt;/p&gt;

&lt;p&gt;SetDensityをONにして、Maximum Distanceを指定することで、距離から0-1の範囲にDensityを設定できます。&lt;/p&gt;

&lt;p&gt;DensityをOneMinusノードで反転してから、Density Filterで中心から離れたポイントを削除します。&lt;/p&gt;

&lt;h3 id=&#34;でdensityを調整&#34;&gt;でDensityを調整&lt;/h3&gt;

&lt;p&gt;PowやMultiplyでDensityを調整します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-12-27-ue5-pcg-introduction-tips/example03-graph-density-multiply.png&#34; alt=&#34;Example03: でDensityを調整&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;定数ノードの作成&#34;&gt;定数ノードの作成&lt;/h4&gt;

&lt;p&gt;2.0や4.0の定数のノードを作成するには、Create Attributeノードを作成し、TypeをDoubeにし、Double Valueを調整します。&lt;/p&gt;

&lt;p&gt;筆者は定数ノードの名前が分からずにしばらく悩みました😱&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-12-27-ue5-pcg-introduction-tips/create-attribute-1.png&#34; alt=&#34;Create Attribute 作成&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-12-27-ue5-pcg-introduction-tips/create-attribute-2.png&#34; alt=&#34;Create Attribute 設定&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;static-meshの生成&#34;&gt;Static Meshの生成&lt;/h3&gt;

&lt;p&gt;最後にStatic Mesh SpawnerでStaticMeshを生成します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-12-27-ue5-pcg-introduction-tips/example03-graph-staticmesh.png&#34; alt=&#34;Create Attribute 設定&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;example04-splineで囲んだ領域内に木を生やす&#34;&gt;Example04: Splineで囲んだ領域内に木を生やす&lt;/h2&gt;

&lt;p&gt;Splineで囲んだ領域内に木を生やす例です。SplineとPCGを組み合わせるためにはブループリントが必要になります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-12-27-ue5-pcg-introduction-tips/example04-result.jpg&#34; alt=&#34;Example04: 結果&#34; /&gt;&lt;/p&gt;

&lt;p&gt;PCG Graphの全体図です。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-12-27-ue5-pcg-introduction-tips/example04-graph-all.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-12-27-ue5-pcg-introduction-tips/example04-graph-all.png&#34; alt=&#34;Example04: PCG Graphの全体図&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;ブループリントの作成&#34;&gt;ブループリントの作成&lt;/h3&gt;

&lt;p&gt;Actorクラスのブループリントを作成します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-12-27-ue5-pcg-introduction-tips/example04-bp.png&#34; alt=&#34;Example04: ブループリント&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ブループリント内にSplineを作成し、Component Tagsに &lt;code&gt;ForestZone&lt;/code&gt; と設定します。&lt;/p&gt;

&lt;p&gt;木を生やす目的以外のSplineを使う場合も想定して、Splineの判別用にComponent Tagsを設定しています。&lt;/p&gt;

&lt;p&gt;たとえば、道に木を生やしたくない場合、RoadのTagを持ったSpline上にポイントをサンプリングして、
Example02で紹介したDifferenceノードで道にある木を削除するような使い方が可能になります。&lt;/p&gt;

&lt;p&gt;次にブループリント内にPCG Componentを作成し、PCG Graphを指定します。&lt;/p&gt;

&lt;h3 id=&#34;spline上のポイント生成&#34;&gt;Spline上のポイント生成&lt;/h3&gt;

&lt;p&gt;Splineの内側にポイント生成します。&lt;/p&gt;

&lt;p&gt;まずは &lt;code&gt;Get Spline Data&lt;/code&gt; でブループリント内にあるSplineを取得します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-12-27-ue5-pcg-introduction-tips/example04-graph-get_spline_data.png&#34; alt=&#34;Example04: Get Spline&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Actor TagsではなくComponent Tagsでフィルターするために、 &lt;code&gt;Filter By Tag&lt;/code&gt; ノードを使いました。&lt;/p&gt;

&lt;p&gt;Component Tagsにした方が1つのActor内に複数のSplineを生成できるので使い勝手が良くなります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-12-27-ue5-pcg-introduction-tips/example04-filter_by_tag.png&#34; alt=&#34;Example04: Filter By Tag&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Spline Sampler&lt;/code&gt; でSplineの内部にポイントを生成します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-12-27-ue5-pcg-introduction-tips/example04-graph-spline_sampler.png&#34; alt=&#34;Example04: Spline Sampler&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Dimention: On Interior（Splineの内側を指定します）&lt;/li&gt;
&lt;li&gt;Unbounded: ON&lt;/li&gt;
&lt;li&gt;Interior Sampling Spacingで密度を調整します&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;landscape上へのプロジェクション&#34;&gt;Landscape上へのプロジェクション&lt;/h3&gt;

&lt;p&gt;Spline上に生成したポイントを &lt;code&gt;Projection&lt;/code&gt; でランドスケープ上に移動します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-12-27-ue5-pcg-introduction-tips/example04-graph-projection.png&#34; alt=&#34;Example04: Projection&#34; /&gt;&lt;/p&gt;

&lt;p&gt;木は上方向に真っ直ぐに生やしたいので、Project Rotations はOFFにしました。&lt;/p&gt;

&lt;h3 id=&#34;重なりを除去-staticmesh生成&#34;&gt;重なりを除去 + StaticMesh生成&lt;/h3&gt;

&lt;p&gt;Example01でも登場した Bounds Modifier と Self Pruning のコンボ技で重なり合ったポイントを消します。&lt;/p&gt;

&lt;p&gt;最後に Static Mesh Spawner でStaticMeshを生成して完了です。&lt;/p&gt;

&lt;p&gt;このあたりの処理は定形パターンですね。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-12-27-ue5-pcg-introduction-tips/example04-graph-static_mesh_spawnerpng.png&#34; alt=&#34;Example04: Projection&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;PCGの基本的なデバッグ方法やよくある処理のパターンを解説しました。&lt;/p&gt;

&lt;p&gt;PCGの基本的な処理の流れとしては、ポイントを生成して、Attributeを処理してから、最後にStaticMeshの生成になります。&lt;/p&gt;

&lt;p&gt;InspectやDebugを使いながらAttributeの変化を確認すれば、あまり迷わずに使いこなすことができると思います。&lt;/p&gt;

&lt;p&gt;StaticMesh上へのポイント生成だったり、複雑なPCGを作成するためにサブグラフ化する方法なども紹介しようと思いましたが、記事が長くなりすぎるので別記事にしたいと思います。&lt;/p&gt;

&lt;p&gt;それでは良いPCGライフを！&lt;/p&gt;

&lt;h1 id=&#34;利用させていただいたasset&#34;&gt;利用させていただいたAsset&lt;/h1&gt;

&lt;p&gt;記事のサンプル作成にあたり、以下のアセットを利用させていただきました。ありがとうございます！&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.unrealengine.com/marketplace/ja/product/landscape-pro-auto-generated-material&#34;&gt;Landscape Pro 2.0 Auto-Generated Material&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Quixel

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://quixel.com/megascans/home?assetId=wjglaj3s&#34;&gt;https://quixel.com/megascans/home?assetId=wjglaj3s&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://quixel.com/megascans/home?assetId=wjglai2s&#34;&gt;https://quixel.com/megascans/home?assetId=wjglai2s&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://quixel.com/megascans/home?assetId=veigfjmaw&#34;&gt;https://quixel.com/megascans/home?assetId=veigfjmaw&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Object Space Raymarching in Unreal Engine 5.2</title>
      <link>https://gam0022.net/blog/2023/07/31/raymarching-in-ue5/</link>
      <pubDate>Mon, 31 Jul 2023 10:00:00 +0900</pubDate>
      
      <guid>https://gam0022.net/blog/2023/07/31/raymarching-in-ue5/</guid>
      <description>&lt;p&gt;これは&lt;a href=&#34;https://sites.google.com/view/rtcamp9/home&#34;&gt;レイトレ合宿9&lt;/a&gt;のアドベントカレンダーの記事です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;あまりレイトレに関連しないテーマですが、レイは飛ばしているので大目に見てください&lt;/li&gt;
&lt;li&gt;レイトレ合宿ではレンダラーを自作する必要があるため、ゲームエンジンは使えません&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/RaymarchingInUE5_thumbnail_v7.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/RaymarchingInUE5_thumbnail_v7.jpg&#34; alt=&#34;Object Space Raymarching in Unreal Engine 5.2&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;はじめに&#34;&gt;はじめに&lt;/h1&gt;

&lt;p&gt;Unreal Engine 5.2上でオブジェクトスペースのレイマーチングを実装したので、その解説をします。&lt;/p&gt;

&lt;p&gt;レイマーチングをノードだけで実装するのは大変なので、MaterialのCustomノードを用いて複雑な処理はHLSLのコードで実装しました。&lt;/p&gt;

&lt;p&gt;UE（Unreal Engine）のプロジェクトはGitHubに公開しています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gam0022/RaymarchingInUE5/&#34;&gt;github.com/gam0022/RaymarchingInUE5/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Object Space Raymarching in Unreal Engine 5.2&lt;a href=&#34;https://twitter.com/hashtag/UE5?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#UE5&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/UnrealEngine?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#UnrealEngine&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/UnrealEngine5?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#UnrealEngine5&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/Shader?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#Shader&lt;/a&gt; &lt;a href=&#34;https://t.co/42n2W87HnJ&#34;&gt;pic.twitter.com/42n2W87HnJ&lt;/a&gt;&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/status/1684596333209075712?ref_src=twsrc%5Etfw&#34;&gt;July 27, 2023&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Randomization of glowing animation borders&lt;a href=&#34;https://twitter.com/hashtag/UE5?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#UE5&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/UnrealEngine?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#UnrealEngine&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/UnrealEngine5?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#UnrealEngine5&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/Shader?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#Shader&lt;/a&gt; &lt;a href=&#34;https://t.co/FvLbVtE9Q3&#34;&gt;pic.twitter.com/FvLbVtE9Q3&lt;/a&gt;&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/status/1685583942920089600?ref_src=twsrc%5Etfw&#34;&gt;July 30, 2023&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;読者対象&#34;&gt;読者対象&lt;/h2&gt;

&lt;p&gt;この記事は以下の読者を対象としています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1週間前の自分&lt;/li&gt;
&lt;li&gt;レイマーチングやシェーダーの実装経験はあるが、UEは初心者の方&lt;/li&gt;
&lt;li&gt;UEのカスタムシェーダーやMaterial Editorに興味がある方&lt;/li&gt;
&lt;li&gt;UE上でノードでは難しい複雑なシェーダーを実装してみたい人&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;結果&#34;&gt;結果&lt;/h1&gt;

&lt;p&gt;まずは実装結果を紹介します。&lt;/p&gt;

&lt;h2 id=&#34;オブジェクトスペースのレイマーチング&#34;&gt;オブジェクトスペースのレイマーチング&lt;/h2&gt;

&lt;p&gt;オブジェクトスペースのレイマーチングを実装しました。カスタムシェーダーをCubeに適用し、レイマーチングを行います。Cubeをレイマーチングのバウンディングボックスとして使用します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/object_space_raymarching_v1.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/object_space_raymarching_v1.png&#34; alt=&#34;オブジェクトスペースのレイマーチング&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;オブジェクトスペースにすることで、フルスクリーンのレイマーチングと比較して処理負荷を抑えることができます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;カメラではなくCubeの表面からレイを飛ばすことで、レイマーチングの衝突判定を少ないイテレーション回数に抑えられる&lt;/li&gt;
&lt;li&gt;レイマーチングの負荷の高いシェーダーの描画範囲を制限できる&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;パラメーターのリアルタイム編集&#34;&gt;パラメーターのリアルタイム編集&lt;/h2&gt;

&lt;p&gt;レイマーチングによる描画を行っているため、フラクタルのパラメーターをリアルタイムに編集できます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/param_v1.gif&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/param_v1.gif&#34; alt=&#34;IFSパラメーターのアニメーション1&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/param_v2.gif&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/param_v2.gif&#34; alt=&#34;IFSパラメーターのアニメーション2&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;▲グローのアニメーションのボーダーを乱数で散らしたバージョン&lt;/p&gt;

&lt;h2 id=&#34;actorのトランスフォームに追従&#34;&gt;Actorのトランスフォームに追従&lt;/h2&gt;

&lt;p&gt;オブジェクトスペースのレイマーチングの実装のため、Actor（UnityのGameObjectに相当）のトランスフォームに追従します。&lt;/p&gt;

&lt;h3 id=&#34;平行移動&#34;&gt;平行移動&lt;/h3&gt;

&lt;p&gt;平行移動の結果を見ると、UEのレンダリング結果と統合できていることがわかります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;他のオブジェクトと相互にライティングの影響を受けている&lt;/li&gt;
&lt;li&gt;床に反射し、ライティング結果が周囲に自然に馴染んでいる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/transform_translation_v1.gif&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/transform_translation_v1.gif&#34; alt=&#34;平行移動&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;回転&#34;&gt;回転&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/transform_rotation_v1.gif&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/transform_rotation_v1.gif&#34; alt=&#34;回転&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;拡大縮小&#34;&gt;拡大縮小&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/transform_scale_v1.gif&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/transform_scale_v1.gif&#34; alt=&#34;拡大縮小&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;実装の解説&#34;&gt;実装の解説&lt;/h1&gt;

&lt;p&gt;ここからは実装の解説をします。&lt;/p&gt;

&lt;h2 id=&#34;実装の全体流れ&#34;&gt;実装の全体流れ&lt;/h2&gt;

&lt;p&gt;以下は実装の流れです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;UE上のHLSL（.ush）シェーダー開発環境の構築

&lt;ul&gt;
&lt;li&gt;C++の開発環境のセットアップ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AddShaderSourceDirectoryMapping&lt;/code&gt; を使用してシェーダーを配置するディレクトリを登録&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;UE上のレイマーチングの実装

&lt;ul&gt;
&lt;li&gt;HLSL（.ush）でレイマーチングを実装&lt;/li&gt;
&lt;li&gt;MaterialのCustomノードの &lt;code&gt;Include File Paths&lt;/code&gt; にHLSLシェーダー（.ush）を指定し、レイマーチングの関数を呼び出す&lt;/li&gt;
&lt;li&gt;Customノードの計算結果をResultノードに出力し、ライティング計算はエンジン側に任せる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;発展的な内容

&lt;ul&gt;
&lt;li&gt;オブジェクトスペースのレイマーチングに対応&lt;/li&gt;
&lt;li&gt;レイマーチングの空間にカメラが潜った場合を考慮&lt;/li&gt;
&lt;li&gt;他のオブジェクトの前後関係の解消&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;hlsl-ush-によるシェーダー開発環境の構築&#34;&gt;HLSL（.ush）によるシェーダー開発環境の構築&lt;/h2&gt;

&lt;p&gt;Unityでは、シェーダーファイル（.shader）をAssetsフォルダーに配置するだけで認識されますが、UEではシェーダーを配置するディレクトリを明示的にエンジンに認識させる必要があります。&lt;/p&gt;

&lt;p&gt;シェーダーを書くためにC++のコードを記述する必要があるのは面倒ですが、仕方ありませんね。&lt;/p&gt;

&lt;p&gt;C++の関数である&lt;a href=&#34;https://docs.unrealengine.com/5.2/en-US/API/Runtime/RenderCore/AddShaderSourceDirectoryMapping/&#34;&gt;AddShaderSourceDirectoryMapping&lt;/a&gt;を呼び出すことで、エンジンがHLSLシェーダー（.ush）を認識できるようになります。&lt;/p&gt;

&lt;p&gt;まずは、C++の開発環境を整える必要があります。以下の記事を参考に、UE用のC++の開発環境をセットアップしました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zenn.dev/posita33/books/ue5_starter_cpp_and_bp_001/viewer/chap_01_vs2022_setup&#34;&gt;Visual Studio 2022のセットアップ｜Unreal Engine 5から始める C++ &amp;amp; Blueprint&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;C++の開発環境をセットアップしたら、次の記事の「普通の方法」を参考にして、AddShaderSourceDirectoryMappingを呼び出してシェーダーを配置するディレクトリをエンジン側に登録します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/takaf51/items/cd98bd83fe5965d0de30#%E6%99%AE%E9%80%9A%E3%81%AE%E6%96%B9%E6%B3%95&#34;&gt;UE4,5 プロジェクトファイル内の外部シェーダーファイル(usf, ush, hlsl)をインクルードする為の設定。 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;手順を箇条書きにすると以下のようになります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C++プロジェクト化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;プロジェクト名.Build.cs&lt;/code&gt; に &lt;code&gt;RenderCore&lt;/code&gt; への依存関係を追加&lt;/li&gt;
&lt;li&gt;プロジェクトにモジュール開始と終了の関数を追加&lt;/li&gt;
&lt;li&gt;モジュール開始のStartupModule()に下記のコードを追加&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;FString ShaderDir = FPaths::Combine(FPaths::ProjectDir(), &amp;quot;Shaders&amp;quot;);
AddShaderSourceDirectoryMapping(&amp;quot;/Project&amp;quot;, ShaderDir);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードにより、プロジェクトの直下にある &lt;code&gt;Shaders&lt;/code&gt; ディレクトリに配置されたHLSLシェーダー（.ush）をエンジン側からIncludeできるようになります。&lt;/p&gt;

&lt;h3 id=&#34;余談-昔のueでhlslの関数定義やincludeは大変だった&#34;&gt;余談：昔のUEでHLSLの関数定義やincludeは大変だった&lt;/h3&gt;

&lt;p&gt;過去のUEでは、HLSLをIncludeすることができず、Customノードの展開される仕様を利用して、関数定義や#includeをインジェクションする必要があったようです。&lt;/p&gt;

&lt;p&gt;これは大変ですね。エンジンの改善により、HLSLのシェーダー開発がより使いやすくなったことは、喜ばしい進化と言えるでしょう。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;もんしょさんと話していたのは、カスタムノードをカッコで閉じちゃえば、あとは自由にコード書けちゃうぜ！というネタです。&lt;br&gt;実はこのTweetのマテリアルもこれを使用して書かれています。&lt;a href=&#34;https://t.co/y3P8BkDWyw&#34;&gt;https://t.co/y3P8BkDWyw&lt;/a&gt; &lt;a href=&#34;https://t.co/M4M5WX4u7m&#34;&gt;pic.twitter.com/M4M5WX4u7m&lt;/a&gt;&lt;/p&gt;&amp;mdash; Takuro Kayumi (@TakuroKX) &lt;a href=&#34;https://twitter.com/TakuroKX/status/670292440369094656?ref_src=twsrc%5Etfw&#34;&gt;November 27, 2015&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://monsho.hatenablog.com/entry/2015/12/23/120142&#34;&gt;Customノード3分ハッキング - もんしょの巣穴ブログ Ver2.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pafuhana1213.hatenablog.com/entry/2015/02/15/152312&#34;&gt;UE4のCustomノード(カスタムHLSLシェーダ)を使ってみた - ぼっちプログラマのメモ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;material全体&#34;&gt;Material全体&lt;/h2&gt;

&lt;p&gt;次の画像はMaterialのグラフ全体です。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_all_text.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_all_text.png&#34; alt=&#34;マテリアル全体&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;このグラフでは、レイマーチングの処理をHLSLで実装し、Customノードから呼び出しています。&lt;/p&gt;

&lt;p&gt;ノードとしては以下の処理のみ実装しています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;カメラのレイの生成&lt;/li&gt;
&lt;li&gt;前後関係の解消のためのPixel Depth Offsetの計算&lt;/li&gt;
&lt;li&gt;Emissiveのパターン計算&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;また、オブジェクトスペースのレイマーチングを行うための座標系の計算もノードで行われています。レイマーチングのCustomノードの前後にはTransformノードが接続されています。&lt;/p&gt;

&lt;h2 id=&#34;hlslシェーダーでレイマーチングを実装&#34;&gt;HLSLシェーダーでレイマーチングを実装&lt;/h2&gt;

&lt;p&gt;MaterialのCustomノードのDetailsからInclude File Pathsを指定し、HLSLファイル（.ush）をインクルードします。&lt;/p&gt;

&lt;p&gt;このとき「実際のファイルパス」と「Include File Paths」の指定に違いがある点に注意してください。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ファイルパスの例: &lt;code&gt;D:\UnrealProjects\プロジェクト名\Shaders\Raymarching.ush&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Include File Paths: &lt;code&gt;/Project/Raymarching.ush&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Raymarching.ush&lt;/code&gt; のHLSLコードの実装例は以下の通りです。レイマーチングの基本的な実装方法については説明しません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#pragma once

float sdBox(float3 p, float3 b)
{
    float3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

// メンガーのスポンジの距離関数
float dMenger(float3 z0, float3 offset, float scale, inout float4 ifsPosition)
{
    float4 z = float4(z0, 1.0);

    [loop]
    for (int n = 0; n &amp;lt; 4; n++)
    {
        z = abs(z);

        if (z.x &amp;lt; z.y) z.xy = z.yx;
        if (z.x &amp;lt; z.z) z.xz = z.zx;
        if (z.y &amp;lt; z.z) z.yz = z.zy;

        z *= scale;
        z.xyz -= offset * (scale - 1.0);

        if (z.z &amp;lt; - 0.5 * offset.z * (scale - 1.0))
        {
            z.z += offset.z * (scale - 1.0);
        }
    }

    ifsPosition = z;

    return (length(max(abs(z.xyz) - float3(1.0, 1.0, 1.0), 0.0)) - 0.05) / z.w;
}

float map(float3 pos, float uniformScale, float3 mengerOffst, float mengerScale, inout float4 ifsPosition)
{
    pos /= uniformScale;

    float d = dMenger(pos, mengerOffst, mengerScale, ifsPosition);
    d *= uniformScale;

    return d;
}

// 偏微分から法線を計算
float3 calcNormal(float3 p, float uniformScale, float3 mengerOffst, float mengerScale, inout float4 ifsPosition)
{
    float eps = 0.001;

    return normalize(float3(
        map(p + float3(eps, 0.0, 0.0), uniformScale, mengerOffst, mengerScale, ifsPosition) - map(p + float3(-eps, 0.0, 0.0), uniformScale, mengerOffst, mengerScale, ifsPosition),
        map(p + float3(0.0, eps, 0.0), uniformScale, mengerOffst, mengerScale, ifsPosition) - map(p + float3(0.0, -eps, 0.0), uniformScale, mengerOffst, mengerScale, ifsPosition),
        map(p + float3(0.0, 0.0, eps), uniformScale, mengerOffst, mengerScale, ifsPosition) - map(p + float3(0.0, 0.0, -eps), uniformScale, mengerOffst, mengerScale, ifsPosition)
    ));
}

// Ambient Occlusionを計算
float calcAO(float3 pos, float3 nor, float uniformScale, float3 mengerOffst, float mengerScale, inout float4 ifsPosition)
{
    float occ = 0.0;
    float sca = 1.0;

    for (int i = 0; i &amp;lt; 5; i++)
    {
        float h = 0.01 + 0.12 * float(i) / 4.0;
        float d = map(pos + h * nor, uniformScale, mengerOffst, mengerScale, ifsPosition);
        occ += (h - d) * sca;
        sca *= 0.95;
        if (occ &amp;gt; 0.35) break;
    }

    return saturate(clamp(1.0 - 3.0 * occ, 0.0, 1.0) * (0.5 + 0.5 * nor.y));
}

// エッジを計算
float calcEdge(float3 p, float uniformScale, float3 mengerOffst, float mengerScale, inout float4 ifsPosition)
{
    float edge = 0.0;
    float2 e = float2(0.01, 0);

    float d1 = map(p + e.xyy, uniformScale, mengerOffst, mengerScale, ifsPosition);
    float d2 = map(p - e.xyy, uniformScale, mengerOffst, mengerScale, ifsPosition);
    float d3 = map(p + e.yxy, uniformScale, mengerOffst, mengerScale, ifsPosition);
    float d4 = map(p - e.yxy, uniformScale, mengerOffst, mengerScale, ifsPosition);
    float d5 = map(p + e.yyx, uniformScale, mengerOffst, mengerScale, ifsPosition);
    float d6 = map(p - e.yyx, uniformScale, mengerOffst, mengerScale, ifsPosition);
    float d = map(p, uniformScale, mengerOffst, mengerScale, ifsPosition) * 2.;

    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);
    edge = smoothstep(0., 1., sqrt(edge / e.x * 2.));

    return edge;
}

// 原点にあるサイズが100x100x100のCubeの内部にいるかどうかを判定
float isInsideCube(float3 p)
{
    return sdBox(p, (50).xxx) &amp;lt;= 0;
}

void raymarching(
    // Inputs
    float3 origin, float3 ray, int raymarchingLoop,
    float uniformScale, float3 mengerOffst, float mengerScale,

    // Additional Outpus
    inout float hit, inout float depth, inout float3 hitPosition, inout float4 ifsPosition,
    inout float3 albedo, inout float3 normal, inout float ao, inout float emissive
)
{
    // レイマーチング
    hit = 0;
    depth = 0.0;// レイの進んだ距離
    float3 p = origin;// レイの先端の座標
    int i = 0;// レイマーチングのループカウンター

    [loop]
    for (i = 0; i &amp;lt; raymarchingLoop; i++)
    {
        float d = map(p, uniformScale, mengerOffst, mengerScale, ifsPosition);

        // 最短距離を0に近似できるなら、オブジェクトに衝突したとみなして、ループを抜けます
        if (abs(d) &amp;lt; 0.1)
        {
            break;
        }

        depth += d;// 最短距離だけレイを進めます
        p = origin + ray * depth;// レイの先端の座標を更新します
    }

    // バウンディングボックスの中にレイが留まっていればヒットしたと判定
    hit = isInsideCube(p);
    hitPosition = p;

    float4 _ifsPosition;

    if (hit)
    {
        // ライティングのパラメーター
        normal = calcNormal(p, uniformScale, mengerOffst, mengerScale, _ifsPosition);// 法線
        emissive = calcEdge(p, uniformScale, mengerOffst, mengerScale, _ifsPosition);// エッジ
        ao = calcAO(p, normal, uniformScale, mengerOffst, mengerScale, _ifsPosition);// AO
    }
    else
    {
        albedo = float3(0, 0, 0);
        discard;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;customノードのdetails&#34;&gt;CustomノードのDetails&lt;/h2&gt;

&lt;p&gt;CustomノードのDetailsは以下のように設定します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_custom_details.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_custom_details.png&#34; alt=&#34;CustomノードのDetails&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;CustomノードのCodeでは、raymarhcing関数を呼び出します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;albedo = objectAlbedo;

raymarching(
    origin, ray, raymarchingLoop,
    uniformScale, mengerOffst, mengerScale,
    hit, depth, hitPosition, ifsPosition,
    albedo, normal, ao, emissive
);

return albedo;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Inputs&lt;/code&gt;と&lt;code&gt;Additional Outpus&lt;/code&gt;には、&lt;code&gt;Raymarching.ush&lt;/code&gt;の&lt;code&gt;raymarching&lt;/code&gt;関数の全パラメーターを指定します。&lt;/p&gt;

&lt;p&gt;パラメーターの多い関数なので手間はかかりますが、ミスのないように注意しながら1個1個指定します。&lt;/p&gt;

&lt;p&gt;注意点として、関数のパラメーターの順序を変更したり、新しいパラメーターを追加すると、ノードの接続情報も再設定する必要があります。&lt;/p&gt;

&lt;!--
UEのMaterialのノードの接続は番号（整数のインデックス）で接続情報を保持しているようなので、パラメーターの順序を入れ替えたり、途中にパラメーターを追加すると、ノード上の接続もやり直しになります。
--&gt;

&lt;p&gt;繰り返しになりますが、Include File Pathsは実際のファイルパスとは異なる点に留意して、&lt;code&gt;/Project/Raymarching.ush&lt;/code&gt;と指定してください。&lt;/p&gt;

&lt;h2 id=&#34;material全体のdetails&#34;&gt;Material全体のDetails&lt;/h2&gt;

&lt;p&gt;Material全体のDetailsは以下のように設定します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_graph_details_text.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_graph_details_text.png&#34; alt=&#34;Material全体のDetails&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Material Domain: Surface

&lt;ul&gt;
&lt;li&gt;レイマーチングはボリュームレダリングの印象があるかもしれませんが、Surfaceで問題ありません&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Blend Mode: Masked

&lt;ul&gt;
&lt;li&gt;レイマーチングの衝突判定によって形状をマスクする必要があります&lt;/li&gt;
&lt;li&gt;このオプションを有効にすることで、Opacity Maskを出力できます

&lt;ul&gt;
&lt;li&gt;交差している場合は1、交差していない場合は0を出力します&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Shading Model: Default Lit

&lt;ul&gt;
&lt;li&gt;ライティング計算はエンジン側に任せます&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Two Sideded: ON

&lt;ul&gt;
&lt;li&gt;カメラがレイマーチングの内部に入った場合に両面描画が必要です&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;materialノード解説-カメラのレイの生成&#34;&gt;Materialノード解説：カメラのレイの生成&lt;/h2&gt;

&lt;p&gt;ここからはノードの解説をします。まずはカメラのレイを生成するためのノードです。&lt;/p&gt;

&lt;p&gt;次のようなノードでカメラのレイを生成しています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_camera_text.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_camera_text.png&#34; alt=&#34;Materialノード解説：カメラのレイの生成&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;レイは2つの3次元ベクトルで定義されます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;origin: レイの原点&lt;/li&gt;
&lt;li&gt;ray: レイの向き&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;rayの計算&#34;&gt;rayの計算&lt;/h3&gt;

&lt;p&gt;レイの方向（ray）はシンプルです。&lt;/p&gt;

&lt;p&gt;カメラの位置と、描画しようとしているSurfaceの座標（Absolute World Position）の差分（Subtract）から計算できます。&lt;/p&gt;

&lt;p&gt;正規化（Normalize）してから、Transform Vectorノードでワールドスペースからローカルスペースに変換しています。&lt;/p&gt;

&lt;p&gt;今回はオブジェクトスペースのレイマーチングのため、レイマーチングのCustomノードに入力する位置や向きはすべてローカルスペースに変換する必要があります。&lt;/p&gt;

&lt;h3 id=&#34;originの計算&#34;&gt;originの計算&lt;/h3&gt;

&lt;p&gt;レイの原点（origin）の計算には分岐（DynamicBranch）があります。&lt;/p&gt;

&lt;p&gt;これはカメラがレイマーチングの空間の内部に潜った場合を考慮しているためです。&lt;/p&gt;

&lt;p&gt;カメラの位置によってoriginを分岐しています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;カメラが外部にある場合: origin = Absolute World Position&lt;/li&gt;
&lt;li&gt;カメラが内部にある場合: origin = カメラの位置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;また、originもローカルスペースにする必要があるため、Transform Positionノードで変換しています。&lt;/p&gt;

&lt;p&gt;カメラの内部/外部の判定はInsideCubeノードで行われています。これもCustomノードです。&lt;/p&gt;

&lt;p&gt;Codeには &lt;code&gt;isInsideCube(localPos)&lt;/code&gt; と指定しています。これは&lt;code&gt;Raymarching.ush&lt;/code&gt;で定義された関数です。&lt;/p&gt;

&lt;p&gt;この分岐によって、カメラがレイマーチングの外部にある場合でも内部にある場合でも、問題なく動作するようになっています。&lt;/p&gt;

&lt;p&gt;また、「Two Sideded: ON」にしている理由は、カメラがレイマーチングの内部に入っている場合において、Cubeの裏面側でレイマーチングを描画するためです。&lt;/p&gt;

&lt;p&gt;これによって、以下のGIFアニメーションでは、カメラがレイマーチングの空間の内部に入り込んだ場合でも正常に描画されています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/camera_inside_v1.gif&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/camera_inside_v1.gif&#34; alt=&#34;カメラがレイマーチングの空間の内部に潜った場合&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;materialノード解説-resultノードへの出力&#34;&gt;Materialノード解説：Resultノードへの出力&lt;/h2&gt;

&lt;p&gt;RaymarchingのCustomノードの出力を、それぞれResultノードに接続します。&lt;/p&gt;

&lt;p&gt;これによりレイマーチングの衝突判定の結果をライティング計算に反映させます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;hit

&lt;ul&gt;
&lt;li&gt;レイマーチングの衝突判定の結果（0なら衝突しなかった、1なら衝突した）です&lt;/li&gt;
&lt;li&gt;Resultノードの &lt;code&gt;Opacity Mask&lt;/code&gt; に接続することで、レイマーチングがヒットしなかったPixelをdiscardできます&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;normal

&lt;ul&gt;
&lt;li&gt;ローカルスペースの法線です&lt;/li&gt;
&lt;li&gt;ワールドスペースに変換（TransformVector）してから、Resultノードの &lt;code&gt;Normal&lt;/code&gt; に接続します&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ao

&lt;ul&gt;
&lt;li&gt;[0-1]のパラメーターなので、そのままResultノードの &lt;code&gt;Ambient Occlusion&lt;/code&gt; に接続します&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_raymarching_result_text.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_raymarching_result_text.png&#34; alt=&#34;Materialノード解説：Resultノードへの出力&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;materialノード解説-前後関係の解決-pixel-depth-offsetの計算&#34;&gt;Materialノード解説：前後関係の解決（Pixel Depth Offsetの計算）&lt;/h2&gt;

&lt;p&gt;他のオブジェクトと重なった場合でも、前後関係を正しく解決するための工夫について説明します。&lt;/p&gt;

&lt;p&gt;以下のGIFアニメーションのように、白い球体と重なっている場合でも、前後関係を正しく解決できています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/depth_transform_v1.gif&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/depth_transform_v1.gif&#34; alt=&#34;前後関係の解決: 平行移動&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/depth_scale_v1.gif&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/depth_scale_v1.gif&#34; alt=&#34;前後関係の解決: スケール&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;UEのMaterialではDepthBufferを直接書き込むことはできませんが、ワールド座標でのDepthの押し込み距離から、Pixel Depth Offsetを計算することで前後関係を解決しています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_pixel_depth_offset_text.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_pixel_depth_offset_text.png&#34; alt=&#34;Materialノード解説：前後関係の解決（Pixel Depth Offsetの計算）&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Pixel Depth Offsetは、ワールド空間でのオフセット距離を計算する必要があります。したがって、Raymarchingの衝突点（hit）をTransform Positionノードを使用してワールド座標に変換し、Absolute World Positionとの差分（Subtract）を計算し、その距離（Length）を計算しています。&lt;/p&gt;

&lt;p&gt;Pixel Depth Offsetでは、カメラの奥方向にのみオフセットできます。逆に手前にオフセットさせることはできません。この制約は、パフォーマンスの向上を目的としています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/EGJ-Nori_Shinoyama/items/42cb29e95eca601250db&#34;&gt;[UE4] Pixel Depth Offsetは何故画面奥にしか行かないのかまた本当に重たいのかどうか問題 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;カメラがレイマーチングの内部にある場合、Cubeの裏面のSurfaceからは、衝突点（hit）が手前に来るため、Pixel Depth Offsetはマイナス値となります。
しかしこのマイナス値は利用できないため、カメラが内部にある場合は、&lt;code&gt;Pixel Depth Offset = 0&lt;/code&gt; となるようにLerpノードで分岐しています&lt;/p&gt;

&lt;!--
今回はLerpで分岐を処理しましたが、`Max(0, x)` でも良いと思います。
--&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;UE5.2でオブジェクトスペースのレイマーチングを実装できた

&lt;ul&gt;
&lt;li&gt;Actorに追従し、通常のMeshのようにギズモによりマウスで配置や変形ができる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;エンジンのレンダリング機能とも破綻なく統合できた

&lt;ul&gt;
&lt;li&gt;床への反射やグローバルイルミネーションに統合できた&lt;/li&gt;
&lt;li&gt;Opacity Mask、Pixel Depth Offsetを利用して、他のオブジェクトの前後関係なども解決できた&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ノードとコードの役割分担をうまくできた

&lt;ul&gt;
&lt;li&gt;複雑な処理はHLSLによるコードで実装し、Customノードで呼び出す&lt;/li&gt;
&lt;li&gt;オブジェクトスペースのための座標変換はノードを利用することでシンプルに実装できた&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;UEの細かいTipsについては別記事でまとめる予定

&lt;ul&gt;
&lt;li&gt;「Ctrl + 1 + 左クリック」でスカラーの定数ノードを作成できる&lt;/li&gt;
&lt;li&gt;VS2022プロジェクトの作成に失敗する場合、Source Code Editorを再選択すると解決することがある&lt;/li&gt;
&lt;li&gt;UnityとUEの座標系やスケールの違いについて&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;参考資料&#34;&gt;参考資料&lt;/h1&gt;

&lt;p&gt;UE4やUnity上でのレイマーチング実装の前例を以下に紹介します。これらの情報をとても参考にさせていただきました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://coposuke.hateblo.jp/entry/2019/12/11/002521&#34;&gt;【UE4】Object Space Raymarching (Material Editor) - コポうぇぶろぐ&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;UE4上でのレイマーチング実装の取り組み&lt;/li&gt;
&lt;li&gt;当時は Include File Paths が存在しなかったため、Customノードの関数定義に対するハックが必要であったことなどに触れています。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nanka.hateblo.jp/entry/2019/08/27/004905&#34;&gt;Unity HDRPのLitシェーダーを改造してレイマーチングする（GBuffer編） - なんかやる&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;Unity HDRP上でのレイマーチング実装の取り組み&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tips.hecomi.com/entry/2016/10/11/225541&#34;&gt;Unity でレイマーチングするシェーダを簡単に作成できるツールを作ってみた&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;Unity ビルドインRP・&lt;a href=&#34;https://tips.hecomi.com/entry/2022/05/31/003815&#34;&gt;URP&lt;/a&gt;上でのレイマーチングの実装の取り組み&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>
